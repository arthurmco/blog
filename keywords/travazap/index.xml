<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>travazap on Blog do Arthur M.</title><link>https://arthurmco.github.io/blog/keywords/travazap/</link><description>Recent content in travazap on Blog do Arthur M.</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Fri, 29 Jul 2022 04:36:31 -0300</lastBuildDate><atom:link href="https://arthurmco.github.io/blog/keywords/travazap/index.xml" rel="self" type="application/rss+xml"/><item><title>TravaZap e TravaLoL: como funcionam? - Parte 1</title><link>https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/</link><pubDate>Fri, 29 Jul 2022 04:36:31 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/</guid><description>Esse √© o primeiro de uma categoria de posts que eu vou fazer chamada de &amp;ldquo;direcionados para todos os p√∫blicos.&amp;rdquo;
Por causa disso, as coisas ser√£o explicadas com mais detalhes, j√° que nem todos entendem os termos t√©cnicos. Se voc√™ achar que eu estou falando muito, √© por isso.
Al√©m disso, as explica√ß√µes que eu vou dar n√£o s√£o para algu√©m com doutorado em ci√™ncias da computa√ß√£o entender, mas sim para sua tia que tomou o travazap do rei do PIX saber o porqu√™ do celular dela ficar lento.</description><content>&lt;p>Esse √© o primeiro de uma categoria de posts que eu vou fazer chamada de
&amp;ldquo;direcionados para todos os p√∫blicos.&amp;rdquo;&lt;/p>
&lt;p>Por causa disso, as coisas ser√£o explicadas com mais detalhes, j√° que nem todos
entendem os termos t√©cnicos. Se voc√™ achar que eu estou falando muito, √© por isso.&lt;/p>
&lt;p>Al√©m disso, as explica√ß√µes que eu vou dar n√£o s√£o para algu√©m com doutorado em ci√™ncias
da computa√ß√£o entender, mas sim para sua tia que tomou o travazap do rei do PIX saber
o porqu√™ do celular dela ficar lento. Ent√£o n√£o seja chato de falar que eu esqueci de
falar alguma coisa. Eu simplifiquei alguns termos para que a mensagem fique mais clara.&lt;/p>
&lt;p>Dito isso, vamos l√°:&lt;/p>
&lt;hr>
&lt;p>Ultimamente os jogadores de League of Legends t√™m reclamado de um tal de &lt;strong>travalol&lt;/strong>, ou &lt;strong>trava lobby&lt;/strong>,
uma esp√©cie de programa que faz com que os jogadores sejam &lt;em>kickados&lt;/em> das partidas.&lt;/p>
&lt;p>No v√≠deo abaixo voc√™ pode ver um v√≠deo do canal &amp;ldquo;Que Crime&amp;rdquo; falando um pouco do Travalol:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/LdK4C5ANZXI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h1 id="uma-explica√ß√£o-b√°sica">Uma explica√ß√£o b√°sica&lt;/h1>
&lt;blockquote>
&lt;p>O TravaZap funciona porque a mensagem do trava cont√©m caracteres especiais.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>O TravaLoL funciona por causa de um bug no client.&lt;/p>
&lt;/blockquote>
&lt;p>Essa explica√ß√£o √© a explica√ß√£o que voc√™ vai achar na grande maioria dos sites. Ela est√° tecnicamente correta,
mas falta algo a mais.&lt;/p>
&lt;h1 id="travazap">TravaZap&lt;/h1>
&lt;p>O TravaZap √© o que me deixou mais curioso, afinal como uma ing√™nua mensagem pode fazer um aplicativo inteiro travar?&lt;/p>
&lt;p>No come√ßo eu achei que era culpa da aplica√ß√£o. Mas, para entender o motivo, eu preciso explicar primeiro o que √© &lt;strong>Unicode&lt;/strong>&lt;/p>
&lt;h2 id="unicode">Unicode&lt;/h2>
&lt;p>Antes, um pouco de hist√≥ria.&lt;/p>
&lt;p>Quando estamos aprendendo a ler, n√≥s somos introduzidos primeiro ao alfabeto:&lt;/p>
&lt;p>&lt;code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&lt;/code>&lt;/p>
&lt;p>Depois, n√≥s somos introduzidos aos numerais:&lt;/p>
&lt;p>&lt;code>0 1 2 3 4 5 6 7 8 9&lt;/code>&lt;/p>
&lt;p>N√≥s sabemos que n√∫meros e letras s√£o coisas diferentes: n√∫meros s√£o mais usados pra contar e letras s√£o mais usadas
para escrever.&lt;/p>
&lt;p>Infelizmente, o computador s√≥ enxerga n√∫meros. Lembrem-se que o computador √©, em seu n√∫cleo, uma m√°quina para
contar, ent√£o ele enxergar apenas n√∫meros faz at√© que um pouco de sentido.&lt;/p>
&lt;p>Esses n√∫meros que o computador enxerga s√£o chamados de &lt;strong>bits&lt;/strong>, e eles s√£o compostos por 0 e 1. &lt;br>
Oito &lt;strong>bits&lt;/strong> s√£o iguais a um &lt;strong>byte&lt;/strong>. Um byte pode ir de 0 a 255.&lt;/p>
&lt;p>Quando o computador come√ßou a se popularizar, foi necess√°rio mostrar texto ao usu√°rio, mensagens mais
claras do que meras luzes em um painel. Ent√£o come√ßaram a inventar jeitos de representarem letras usando n√∫meros.&lt;/p>
&lt;p>O padr√£o mais usado durante muito tempo foi o &lt;strong>ASCII&lt;/strong>. Ele usa um byte por letra (ou seja, vai de 0 at√© 255[*]),
diferencia mai√∫sculas de min√∫sculas, e tem a maioria dos caracteres com acento. No ASCII, a letra &lt;strong>A&lt;/strong> √© codificada
usando o n√∫mero &lt;strong>65&lt;/strong>.&lt;/p>
&lt;p>Infelizmente, o ASCII, devido a limita√ß√µes de armazenamento na √©poca, apenas guarda caracteres do alfabeto latino
e alguns acentos. Se voc√™ quiser escrever, por exemplo, ÁßÅ„ÅÆ„Ç≥„ÉÉ„ÇØ„ÅØÂ∑®Â§ß„Åß„Åô, voc√™ n√£o vai conseguir usando ASCII.
Obviamente era poss√≠vel naquela √©poca, j√° que os japoneses usavam computadores, mas n√£o usando ASCII. Sim, voc√™ teria
que trocar de encoding, o que provavelmente iria corromper seu texto, j√° que apenas os n√∫meros e caracteres de
letra mai√∫scula eram iguais entre os encodings da √©poca.&lt;/p>
&lt;p>Voc√™ j√° deve ter visto muitos textos assim, principalmente se voc√™ for mais velho:&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/acento.png" alt="Erro de encoding no windows 98">&lt;/p>
&lt;p>Esse erro ocorre porque o sistema operacional, o Windows no caso, estava usando o encoding errado. O padr√£o √© ASCII,
mas o Windows 98 usava uma encoding chamada &lt;a href="https://pt.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1&lt;/a>, tamb√©m chamada
Latin-1, para encodificar os caracteres em portugu√™s.&lt;/p>
&lt;p>As pessoas j√° estavam cansadas de problemas como esse, que limitam a comunica√ß√£o. E olha que a diferen√ßa entre o Latin-1
pro ASCII era pequena: em muitos encodings, o que restava de semelhante ao ASCII eram apenas n√∫meros e letras mai√∫sculas.&lt;/p>
&lt;p>O desejo por um padr√£o universal come√ßou, e o Unicode surgiu a partir da√≠.&lt;/p>
&lt;p>[*] Tecnicamente o ASCII vai at√© 127, por motivos que fogem ao assunto desse post.&lt;/p>
&lt;h2 id="utf-8">UTF-8&lt;/h2>
&lt;p>O Unicode representa caracteres em valores chamados de &lt;strong>codepoints&lt;/strong>, e eles s√£o representados exclusivamente em hexadecimal.
Esses caracteres v√£o desde letras e n√∫meros em diferentes idiomas at√© &lt;em>kanjis&lt;/em>, hieroglifos e emojis.&lt;br>
Por exemplo, üí© √© representado pelo codepoint 1F4A9, equivalente a 128169 em decimal.&lt;/p>
&lt;p>Todos os codepoints come√ßam com U seguidos do n√∫mero, ent√£o o codepoint que representa a atual situa√ß√£o do nosso amado pa√≠s
seria escrito U+1F4A9.&lt;/p>
&lt;p>Por√©m, esses &lt;strong>codepoints&lt;/strong> n√£o dizem nada sobre como voc√™ os representa na m√°quina. Para isso, existem m√©todos de mapeamento. Os mais
comuns se chamam UTF, ou &lt;em>Unicode Transformation Format&lt;/em>, algo como &lt;strong>Formato de Transforma√ß√£o Unicode&lt;/strong>, que vai mapear o codepoint em
bytes, para serem usados pelo software.&lt;/p>
&lt;p>O mais popular √© o UTF-8. Nele, voc√™ usa no m√≠nimo um byte e no m√°ximo oito, se eu n√£o me engano. Os bytes que cada codepoint depende do
n√∫mero do codepoint. Felizmente, os 127 primeiros caracteres t√™m o mesmo valor tanto em UTF-8, quanto Unicode e quanto ASCII, ent√£o
n√£o h√° mudan√ßas (por isso que √© t√£o popular). Todos os sistemas operacionais s√£o compat√≠veis e usam UTF-8.&lt;/p>
&lt;p>Existe o UTF-16, onde voc√™ usa entre dois e oito.&lt;/p>
&lt;p>E existe o UTF-32, que voc√™ usa entre quatro e oito, se eu n√£o me engano.&lt;/p>
&lt;p>Muito embora, na pr√°tica, o limite m√°ximo seja quatro.&lt;/p>
&lt;p>Antigamente, o Windows usava um formato chamado &lt;strong>UCS-2&lt;/strong>, que usava exatamente dois bytes por codepoint.&lt;/p>
&lt;p>E, sim, letra e codepoint s√£o coisas diferentes. Por exemplo, existem duas formas de escrever a letra &lt;code>√°&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>U+00E1&lt;/li>
&lt;li>U+0061 U+0301.&lt;/li>
&lt;/ul>
&lt;p>Na primeira forma voc√™ usa o codepoint responsavel pela letra &lt;code>√°&lt;/code>.&lt;/p>
&lt;p>Na segunda voc√™ usa 2 codepoints: um pra letra &lt;code>a&lt;/code> (sem acento) e outro que representa o ato de acentuar o
codepoint anterior.&lt;/p>
&lt;h2 id="navegando-pelo-texto">Navegando pelo texto&lt;/h2>
&lt;p>Voc√™ deve estar se perguntando: o que isso tem a ver com o travazap?&lt;/p>
&lt;p>Acalme-se.&lt;/p>
&lt;p>√â importante que voc√™ veja a explica√ß√£o, principalmente na parte que eu falei que, no UTF-8,
&lt;em>voc√™ usa no m√≠nimo um byte e no m√°ximo seis&lt;/em>.&lt;/p>
&lt;p>N√£o, o valor de bytes por caractere n√£o √© fixo.&lt;/p>
&lt;p>Por exemplo, se convertermos a frase &amp;ldquo;Luladr√£o roubou meu cora√ß√£o&amp;rdquo; para UTF-8, teremos:
(cada n√∫mero sendo um byte, em hexadecimal)&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 4c 75 6c 61 64 72 c3 a3 6f 2c 20 72 6f 75 62 6f |Luladr..o, roubo|
L u l a d r --√£-- o , r o u b o
00000010 75 20 6d 65 75 20 63 6f 72 61 c3 a7 c3 a3 6f |u meu cora....o|
u m e u c o r a --√ß-- --√£-- o
&lt;/code>&lt;/pre>&lt;p>Perceba que os caracteres com acento ocuparam dois bytes?&lt;/p>
&lt;ul>
&lt;li>&lt;code>√£&lt;/code> √© representado pelos bytes C3 e A3 (195 e 163 em decimal).&lt;/li>
&lt;li>&lt;code>√ß&lt;/code> √© representado pelos bytes C3 e A7 (195 e 167 em decimal).&lt;/li>
&lt;/ul>
&lt;p>Antigamente, em ASCII, um caractere era igual a um byte. Ent√£o, para voc√™, por exemplo, andar
dez caracteres para frente num texto, voc√™ simplesmente pulava dez bytes. Voc√™ nem precisaria
se preocupar no que est√° escrito, j√° que o tamanho √© fixo.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/squid1.png" alt="Antigamente, as letras eram assim">&lt;/p>
&lt;p>J√° no UTF-8, voc√™ precisa prestar aten√ß√£o no byte que voc√™ est√° lendo, para ver se o caractere
tem um ou mais bytes.&lt;/p>
&lt;p>Isso torna opera√ß√µes de manipula√ß√£o de texto, como contar letras e palavras, al√©m de descobrir
o tamanho de um peda√ßo de texto em caracteres, relativamente mais dif√≠cil.&lt;/p>
&lt;h2 id="escrita">Escrita&lt;/h2>
&lt;p>Algo que se torna mais complicado √© desenhar as letras que voc√™ v√™ na tela.&lt;/p>
&lt;p>Antigamente, quando se usava apenas ASCII, o computador ordenava os 256 caracteres do ASCII em uma
lista na mem√≥ria, e usava o valor da letra para se decidir qual caractere desenhar. Por exemplo, se
voc√™ pedisse para ele desenhar o caractere de valor &lt;code>65&lt;/code>, o computador iria ver o 65¬∫ caractere da lista,
que seria a letra &amp;ldquo;A&amp;rdquo;, e o desenharia onde voc√™ pediu.&lt;/p>
&lt;p>Como eram apenas 256 valores, n√£o tinha problema em ter uma tabela gigantesca em mem√≥ria.&lt;/p>
&lt;p>Por√©m, a primeira vers√£o do Unicode j√° vinha com dezenas de milhares de &amp;ldquo;caracteres&amp;rdquo; (codepoints, na verdade).
A primeira vers√£o lan√ßou ainda na d√©cada de 90, onde os computadores possu√≠am, em m√©dia, uns 128 MB de mem√≥ria.
Uma simples lista caberia, mas n√£o sobraria muito para outros aplicativos.&lt;/p>
&lt;p>Ent√£o os cientistas da computa√ß√£o inventaram jeitos melhores de guardar esses caracteres na mem√≥ria, e diferentes
formatos de fontes de computador nasceram. Jeitos melhores obviamente aumentaram a velocidade, mas aumentavam
tamb√©m o tamanho desses arquivos, al√©m do consumo de mem√≥ria da m√°quina.&lt;/p>
&lt;p>Por√©m, uma coisa que mudou √© que, antigamente, todos os caracteres tinham um tamanho fixo, de alguns pixels.&lt;br>
Por exemplo, se uma letra tem 7 pixels de largura, e voc√™ precisa escrever a palavra &lt;code>PA√áOCA&lt;/code>, voc√™ sabe que
precisa reservar &lt;code>7&lt;/code> pixels * &lt;code>6&lt;/code> caracteres, ou seja, 42 pixels.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/pafoca.png" alt="&amp;amp;ldquo;Pa√ßoca&amp;amp;rdquo; escrita em diferentes tipos de letra, para ilustrar os diferentes tamanhos">
&lt;!-- raw HTML omitted -->&amp;ldquo;Pa√ßoca&amp;rdquo; escrita em diferentes tipos de letra, para ilustrar os diferentes tamanhos&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>Agora, um caractere pode ter diferentes tamanhos, ent√£o o programa nunca sabe qual vai ser o tamanho da letra que
ele vai desenhar at√© ele desenhar. Sim, a altura ainda √© conhecida, mas a largura n√£o.&lt;/p>
&lt;h2 id="problemas">Problemas&lt;/h2>
&lt;p>Ent√£o, n√≥s temos dois problemas:&lt;/p>
&lt;ul>
&lt;li>Um &lt;strong>caractere&lt;/strong> pode ser composto por v√°rios &lt;strong>codepoints&lt;/strong>.&lt;/li>
&lt;li>Um &lt;strong>codepoint&lt;/strong> pode ser composto por v√°rios &lt;strong>bytes&lt;/strong>.&lt;/li>
&lt;li>Um &lt;strong>caractere&lt;/strong> pode ter diferentes larguras.&lt;/li>
&lt;li>Al√©m disso, um &lt;strong>caractere&lt;/strong> pode ser desenhado de tr√°s pra frente, ou de cima para baixo.&lt;/li>
&lt;/ul>
&lt;p>Identificar caracteres √© dif√≠cil, mas desenh√°-los na tela √© ainda mais.&lt;/p>
&lt;p>O motivo pelo qual isso n√£o parece lento √© que os programas geralmente, na hora de editar texto, ou
deixam quatro bytes por codepoint, fazendo com que seja muito mais f√°cil de navegar, ou usam
algoritmos que permitem navega√ß√£o r√°pida, a custo de mais mem√≥ria consumida.&lt;/p>
&lt;p>Al√©m disso, eles s√≥ desenham os caracteres que v√£o aparecer na tela, o que limita um pouco as coisas.&lt;/p>
&lt;h2 id="voltando-√†-quest√£o">Voltando √† quest√£o.&lt;/h2>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/travazap.jpg" alt="">
&lt;!-- raw HTML omitted -->Fonte: radaroeste.com.br&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>At√© agora, sabemos que:&lt;/p>
&lt;ul>
&lt;li>os caracteres podem ocupar mais de um byte.&lt;/li>
&lt;li>cada caractere pode ter diferentes tamanhos.&lt;/li>
&lt;li>a parte mais demorada envolve desenhar o caractere.&lt;/li>
&lt;/ul>
&lt;p>Dito isso, j√° posso explicar como funciona o travazap.&lt;/p>
&lt;p>N√£o, n√£o √© nada a ver com os servidores do whatsapp. O Whatsapp usa uma linguagem chamada &lt;strong>Erlang&lt;/strong>
para criar o programa que fica no servidor, enviando as mensagens para os aplicativos lhe mostrarem. &lt;br>
Essa linguagem tem um bom suporte a Unicode.&lt;/p>
&lt;p>O aplicativo em si √© feito em Java, se eu n√£o me engano. Java tem um bom suporte a unicode.&lt;/p>
&lt;p>E, para falar a verdade, o tratamento de Unicode j√° √© conhecido faz tempo. Qualquer linguagem de
programa√ß√£o tem fun√ß√µes que lidam com isso.&lt;/p>
&lt;p>O problema est√° na hora de desenhar.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/pombo.png" alt="">&lt;/p>
&lt;p>Isso √© um travazap que eu peguei da internet, inalterado. &lt;br>
Ele tem 110 kB.&lt;br>
Pode n√£o parecer muito, mas isso s√£o, aproximadamente, 100 mil caracteres.&lt;/p>
&lt;p>Voc√™ j√° pode perceber que tem algo errado, j√° que os travazaps n√£o parecem ser t√£o grandes.
No m√°ximo eles t√™m uma tela ou duas. Isso n√£o d√° cem mil caracteres nunca, nem na menor
fonte poss√≠vel que voc√™ pode configurar no celular.&lt;/p>
&lt;p>O problema, na verdade, est√° em &lt;em>desenhar&lt;/em>.&lt;/p>
&lt;p>A maior parte do travazap √© composta por esses codepoints aqui:&lt;/p>
&lt;ul>
&lt;li>&lt;code>U+2009&lt;/code>&lt;/li>
&lt;li>&lt;code>U+200A&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Se voc√™ souber ingl√™s, vai ver que &lt;a href="https://unicode-explorer.com/c/2009">o nome do primeiro codepoint&lt;/a>
√© algo como &amp;ldquo;ESPA√áO PEQUENO&amp;rdquo;, e &lt;a href="https://unicode-explorer.com/c/200A">o nome do segundo&lt;/a>
√© algo como &amp;ldquo;ESPA√áO DO TAMANHO DE UM FIO DE CABELO&amp;rdquo;.&lt;/p>
&lt;p>O &lt;code>2009&lt;/code> √© o segundo menor espa√ßo dispon√≠vel, medindo algo como 3 pixels. O &lt;code>200A&lt;/code> √© ainda menor do que
isso. Lembrando que as telas de celular de hoje em dia possuem algo como 720 pixels de largura[2],
ent√£o cabem uns 300 caracteres desses por linha.&lt;/p>
&lt;p>Esses dois caracteres n√£o s√£o muito dif√≠ceis de serem desenhados, mas, ainda assim, o WhatsApp precisa
desenh√°-los um a um. E, como os caracteres s√£o bem pequenos, voc√™ precisa desenhar muitos deles
para chegar at√© o final da tela.&lt;/p>
&lt;p>Ao contr√°rio do seu navegador, Chrome ou Firefox, que j√° √© otimizado para lidar com muito texto (
lembrando que, tecnicamente, s√£o &lt;strong>100 mil caracteres de uma vez&lt;/strong> ), o WhatsApp n√£o √©, e ele
acaba travando.&lt;/p>
&lt;p>Muitos travazaps cont√©m &lt;em>codepoints&lt;/em> que mudam a dire√ß√£o do texto, o que tamb√©m afeta a velocidade
de desenho, j√° que voc√™ precisa calcular a medida da letra de tr√°s para frente, e ir andando
pelo texto at√© achar o &lt;em>codepoint&lt;/em> que volta a dire√ß√£o do texto ao normal.&lt;/p>
&lt;p>&lt;strong>Fato curioso:&lt;/strong> o travazap n√£o funciona com SMS da mesma forma que com o WhatsApp.&lt;br>
Sim, o SMS suporta Unicode, mas ele tem um limite &lt;em>em bytes&lt;/em>, e esse limite √© relativamente
pequeno. Ent√£o voc√™ n√£o vai ver tantos caracteres. &lt;em>MASSSS&lt;/em>, voc√™ vai receber muitas mensagens
de uma vez, umas mil, uma atr√°s da outra.&lt;br>
√â &lt;em>isso&lt;/em> √© o qe pode travar o seu celular&lt;/p>
&lt;hr>
&lt;p>[2] 720 pixels &lt;em>virtuais&lt;/em>. Na verdade, a tela tem, no m√≠nimo, o dobro dessa resolu√ß√£o, mas ela √©
mais usada pelo sistema pra suavizar as bordas das letras e melhorar a defini√ß√£o das imagens.\
Para o aplicativo, √© uma tela de 720 pixels.&lt;/p>
&lt;hr>
&lt;p>Pronto, TravaZap explicado!&lt;/p>
&lt;p>Na parte 2, que eu ainda vou escrever, eu vou falar mais ou menos como funciona o TravaLoL novo.
Como eu ainda estou pesquisando, vai demorar um pouco mais.&lt;/p></content></item></channel></rss>