<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>estrutura on Blog do Arthur M.</title><link>https://arthurmco.github.io/blog/keywords/estrutura/</link><description>Recent content in estrutura on Blog do Arthur M.</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Thu, 11 Aug 2022 14:25:28 -0300</lastBuildDate><atom:link href="https://arthurmco.github.io/blog/keywords/estrutura/index.xml" rel="self" type="application/rss+xml"/><item><title>Formatinhos: Prelúdio</title><link>https://arthurmco.github.io/blog/posts/meta-glossario-formatinhos/</link><pubDate>Thu, 11 Aug 2022 14:25:28 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/meta-glossario-formatinhos/</guid><description>&lt;p>Amanhã é o lançamento da minha série dos formatinhos, com o primeiro episódio sendo o dos
arquivos &lt;strong>.bmp&lt;/strong>&lt;/p>
&lt;p>Os posts da série terão descrições padronizadas de algumas estruturas de dados. Alguns de vocês
podem estar familiarizados com esse tipo de descrição, mas, como eu tento escrever para os
júniores e as sandys, eu vou explicar.&lt;/p>
&lt;p>Se você começar a ler esse post e se pegar pensando &amp;ldquo;Eu já sei isso&amp;rdquo;, então você já pode começar
a ver a série dos formatinhos.&lt;/p></description><content>&lt;p>Amanhã é o lançamento da minha série dos formatinhos, com o primeiro episódio sendo o dos
arquivos &lt;strong>.bmp&lt;/strong>&lt;/p>
&lt;p>Os posts da série terão descrições padronizadas de algumas estruturas de dados. Alguns de vocês
podem estar familiarizados com esse tipo de descrição, mas, como eu tento escrever para os
júniores e as sandys, eu vou explicar.&lt;/p>
&lt;p>Se você começar a ler esse post e se pegar pensando &amp;ldquo;Eu já sei isso&amp;rdquo;, então você já pode começar
a ver a série dos formatinhos.&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>Antes de mais nada, leia isso:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Numeração hexadecimal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pt.wikipedia.org/wiki/Extremidade_(ordena%C3%A7%C3%A3o)">Extremidade (ou &lt;em>endianness&lt;/em>)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Vai ser importante lá na frente!&lt;/p>
&lt;/blockquote>
&lt;p>O código será mostrado assim (aprendi a formatar o código desse jeito nessa semana, e fica bem
mais bonito, dá pra expandir e fica melhor em mobile.)&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="819574326" type="checkbox" />
&lt;label for="819574326">
&lt;span class="collapsable-code__language">c&amp;#43;&amp;#43;&lt;/span>
&lt;span class="collapsable-code__title">Código exemplo&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-c&amp;#43;&amp;#43;" >&lt;code>
#include &amp;lt;cstdint&amp;gt;
#include &amp;lt;string&amp;gt;
struct Teste {
int8_t val1;
int8_t val2;
std::string str;
}
int testa_o_teste(const Teste&amp;amp; teste, int valor) {
// aaaaaaa
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Eu vou tentar ser o mais didático possível no código. Se algo não ficar claro, você pode comentar.&lt;/p>
&lt;p>Em algumas partes do post, eu vou precisar mostrar dumps hexadecimais e estruturas de dados,
geralmente juntos.&lt;/p>
&lt;p>Um dump hexadecimal é algo parecido com isso:&lt;br>
(Ele quebra em mobile :(. Até eu resolver isso, veja esse dump com o celular na horizontal)&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 45 58 45 4d 00 04 00 00 00 04 00 00 20 03 8f 3d |EXEM........ ..=|
00000010 18 00 00 00 20 03 00 00 41 69 20 71 75 65 20 73 |.... ...Ai que s|
00000020 61 63 6f 00 |aco.|
00000024
&lt;/code>&lt;/pre>&lt;p>O dump acima está em um formato padrão (de um programa chamado &lt;code>hexdump&lt;/code>). Todos os valores
das três primeiras colunas estão em hexadecimal.&lt;/p>
&lt;p>A primeira coluna mostra um valor que representa a posição do byte logo depois dela,
em hexadecimal. (&lt;code>00000010&lt;/code> = 16 em decimal, &lt;code>00000020&lt;/code> = 32 em decimal, &lt;code>00000024&lt;/code> = 36).&lt;/p>
&lt;p>A segunda coluna mostra os bytes 0 até 7 da linha. Ou seja:&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 45 58 45 4d 00 04 00 00
&lt;/code>&lt;/pre>&lt;p>O primeiro byte é &lt;code>45&lt;/code>, o segundo é &lt;code>58&lt;/code>, o terceiro é &lt;code>45&lt;/code> denovo&amp;hellip;&lt;/p>
&lt;pre tabindex="0">&lt;code>00000010 18 00 00 00 20 03 00 00
&lt;/code>&lt;/pre>&lt;p>O décimo sexto byte é &lt;code>18&lt;/code>, do 17 ao 19 são &lt;code>00&lt;/code>, o vigésimo byte, por coincidéncia, é &lt;code>20&lt;/code>&amp;hellip;&lt;/p>
&lt;p>E por aí vai&lt;/p>
&lt;p>A terceira coluna mostra os bytes 8 até 15. Mesmo esquema.&lt;/p>
&lt;p>A quarta coluna é a representação, em ASCII, dos bytes daquela linha:&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 45 58 45 4d 00 04 00 00 00 04 00 00 20 03 8f 3d |EXEM........ ..=|
&lt;/code>&lt;/pre>&lt;p>&amp;lsquo;E&amp;rsquo; = &lt;code>45&lt;/code>, &amp;lsquo;X&amp;rsquo; = &lt;code>58&lt;/code>, &amp;lsquo;M&amp;rsquo; = &lt;code>4d&lt;/code>&amp;hellip; você entendeu. Os valores que não têm um caractere
correspondente printável são representados com um ponto.&lt;/p>
&lt;p>Geralmente, o dump vai vir acompanhado de uma tabela mostrando o que tem dentro do arquivo.&lt;br>
Cada linha da tabela é um &lt;strong>campo&lt;/strong>, um valor que significa alguma coisa.&lt;br>
Por exemplo:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Posição&lt;/th>
&lt;th>Tamanho&lt;/th>
&lt;th>Campo&lt;/th>
&lt;th>Valor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>0x0 (0) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>MAGIC&lt;/td>
&lt;td>&lt;code>45 58 45 4d&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x4 (4) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>width&lt;/td>
&lt;td>&lt;code>0x400&lt;/code> = 1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x8 (8) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>height&lt;/td>
&lt;td>&lt;code>0x400&lt;/code> = 1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xC (12) &lt;/code>&lt;/td>
&lt;td>1&lt;/td>
&lt;td>bit depth&lt;/td>
&lt;td>&lt;code>0x20&lt;/code> = 32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xD (13) &lt;/code>&lt;/td>
&lt;td>1&lt;/td>
&lt;td>compression&lt;/td>
&lt;td>&lt;code>0x3&lt;/code> = RLE8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xE (14) &lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>checksum&lt;/td>
&lt;td>&lt;code>8f 3d&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x10 (16) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>name offset&lt;/td>
&lt;td>&lt;code>0x18&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x14 (20) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>data offset&lt;/td>
&lt;td>&lt;code>0x320&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Na coluna &lt;strong>Posição&lt;/strong> eu mostro em qual posição (tanto em decimal quanto em hexadecimal) o campo
fica dentro do arquivo. A posição sempre vai ser em bytes.&lt;/p>
&lt;p>O &lt;strong>Tamanho&lt;/strong> é o tamanho, em bytes, daquele campo.&lt;/p>
&lt;p>O &lt;strong>campo&lt;/strong> é o nome do campo, como ele está na documentação. Se a documentação for informal, vai
ser um nome que eu vou inventar e que descreve o campo.&lt;/p>
&lt;p>O &lt;strong>valor&lt;/strong> é o valor atual do campo, pra você não precisar gastar neurônios caçando a posição
exata do campo. Os valores que significam números estão convertidos, e os zeros extras são
removidos.&lt;/p>
&lt;p>Eu geralmente vou mostrar campos com tamanho variável separadamente. Por exemplo:&lt;/p>
&lt;ul>
&lt;li>O campo &lt;code>name offset&lt;/code> aponta para uma &lt;em>string&lt;/em> terminada em &lt;code>NUL&lt;/code> (&lt;code>&amp;quot;Ai que saco&amp;quot;&lt;/code>).&lt;/li>
&lt;/ul>
&lt;p>Uma string terminada em &lt;code>NUL&lt;/code> é uma string que termina em um byte &lt;code>0&lt;/code>. É a string que o C usa.&lt;/p>
&lt;hr>
&lt;p>E é isso.&lt;/p>
&lt;p>Se você sentiu que eu não expliquei algo direito, comente aí que eu altero a postagem explicando
melhor.&lt;/p>
&lt;p>Amanhã a gente começa!&lt;/p></content></item></channel></rss>