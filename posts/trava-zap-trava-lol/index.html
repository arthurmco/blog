<!doctype html><html lang=en><head><title>TravaZap e TravaLoL: como funcionam? - Parte 1 :: Blog do Arthur M.</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Apesar do nome parecido, os dois funcionam de formas diferentes. 

O travazap, por exemplo, trava o zap porque a mensagem √© lotada de *espa√ßos invis√≠veis*.
"><meta name=keywords content="travazap,travalol"><meta name=robots content="noodp"><link rel=canonical href=https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/style.css><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/red.css><link rel=apple-touch-icon href=https://arthurmco.github.io/blog/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://arthurmco.github.io/blog/img/favicon/red.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="TravaZap e TravaLoL: como funcionam? - Parte 1"><meta property="og:description" content="Apesar do nome parecido, os dois funcionam de formas diferentes. 

O travazap, por exemplo, trava o zap porque a mensagem √© lotada de *espa√ßos invis√≠veis*.
"><meta property="og:url" content="https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/"><meta property="og:site_name" content="Blog do Arthur M."><meta property="og:image" content="https://arthurmco.github.io/blog/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-07-29 04:36:31 -0300 -0300"></head><body class=red><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://arthurmco.github.io/blog/><div class=logo>Blog do Arthur M.</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/>TravaZap e TravaLoL: como funcionam? - Parte 1</a></h1><div class=post-meta><span class=post-date>2022-07-29
[Modificado em: 2022-07-29]</span>
<span class=post-author>:: Arthur Mendes</span>
<span class=post-reading-time><br>11
minutos
estimados de leitura</span></div><span class=post-tags>#<a href=https://arthurmco.github.io/blog/tags/tips/>tips</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/simple/>simple</a>&nbsp;</span><div class=post-content><div><p>Esse √© o primeiro de uma categoria de posts que eu vou fazer chamada de
&ldquo;direcionados para todos os p√∫blicos.&rdquo;</p><p>Por causa disso, as coisas ser√£o explicadas com mais detalhes, j√° que nem todos
entendem os termos t√©cnicos. Se voc√™ achar que eu estou falando muito, √© por isso.</p><p>Al√©m disso, as explica√ß√µes que eu vou dar n√£o s√£o para algu√©m com doutorado em ci√™ncias
da computa√ß√£o entender, mas sim para sua tia que tomou o travazap do rei do PIX saber
o porqu√™ do celular dela ficar lento. Ent√£o n√£o seja chato de falar que eu esqueci de
falar alguma coisa. Eu simplifiquei alguns termos para que a mensagem fique mais clara.</p><p>Dito isso, vamos l√°:</p><hr><p>Ultimamente os jogadores de League of Legends t√™m reclamado de um tal de <strong>travalol</strong>, ou <strong>trava lobby</strong>,
uma esp√©cie de programa que faz com que os jogadores sejam <em>kickados</em> das partidas.</p><p>No v√≠deo abaixo voc√™ pode ver um v√≠deo do canal &ldquo;Que Crime&rdquo; falando um pouco do Travalol:</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/LdK4C5ANZXI style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><h1 id=uma-explica√ß√£o-b√°sica>Uma explica√ß√£o b√°sica<a href=#uma-explica√ß√£o-b√°sica class=hanchor arialabel=Anchor>&#8983;</a></h1><blockquote><p>O TravaZap funciona porque a mensagem do trava cont√©m caracteres especiais.</p></blockquote><blockquote><p>O TravaLoL funciona por causa de um bug no client.</p></blockquote><p>Essa explica√ß√£o √© a explica√ß√£o que voc√™ vai achar na grande maioria dos sites. Ela est√° tecnicamente correta,
mas falta algo a mais.</p><h1 id=travazap>TravaZap<a href=#travazap class=hanchor arialabel=Anchor>&#8983;</a></h1><p>O TravaZap √© o que me deixou mais curioso, afinal como uma ing√™nua mensagem pode fazer um aplicativo inteiro travar?</p><p>No come√ßo eu achei que era culpa da aplica√ß√£o. Mas, para entender o motivo, eu preciso explicar primeiro o que √© <strong>Unicode</strong></p><h2 id=unicode>Unicode<a href=#unicode class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Antes, um pouco de hist√≥ria.</p><p>Quando estamos aprendendo a ler, n√≥s somos introduzidos primeiro ao alfabeto:</p><p><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code></p><p>Depois, n√≥s somos introduzidos aos numerais:</p><p><code>0 1 2 3 4 5 6 7 8 9</code></p><p>N√≥s sabemos que n√∫meros e letras s√£o coisas diferentes: n√∫meros s√£o mais usados pra contar e letras s√£o mais usadas
para escrever.</p><p>Infelizmente, o computador s√≥ enxerga n√∫meros. Lembrem-se que o computador √©, em seu n√∫cleo, uma m√°quina para
contar, ent√£o ele enxergar apenas n√∫meros faz at√© que um pouco de sentido.</p><p>Esses n√∫meros que o computador enxerga s√£o chamados de <strong>bits</strong>, e eles s√£o compostos por 0 e 1.<br>Oito <strong>bits</strong> s√£o iguais a um <strong>byte</strong>. Um byte pode ir de 0 a 255.</p><p>Quando o computador come√ßou a se popularizar, foi necess√°rio mostrar texto ao usu√°rio, mensagens mais
claras do que meras luzes em um painel. Ent√£o come√ßaram a inventar jeitos de representarem letras usando n√∫meros.</p><p>O padr√£o mais usado durante muito tempo foi o <strong>ASCII</strong>. Ele usa um byte por letra (ou seja, vai de 0 at√© 255[*]),
diferencia mai√∫sculas de min√∫sculas, e tem a maioria dos caracteres com acento. No ASCII, a letra <strong>A</strong> √© codificada
usando o n√∫mero <strong>65</strong>.</p><p>Infelizmente, o ASCII, devido a limita√ß√µes de armazenamento na √©poca, apenas guarda caracteres do alfabeto latino
e alguns acentos. Se voc√™ quiser escrever, por exemplo, ÁßÅ„ÅÆ„Ç≥„ÉÉ„ÇØ„ÅØÂ∑®Â§ß„Åß„Åô, voc√™ n√£o vai conseguir usando ASCII.
Obviamente era poss√≠vel naquela √©poca, j√° que os japoneses usavam computadores, mas n√£o usando ASCII. Sim, voc√™ teria
que trocar de encoding, o que provavelmente iria corromper seu texto, j√° que apenas os n√∫meros e caracteres de
letra mai√∫scula eram iguais entre os encodings da √©poca.</p><p>Voc√™ j√° deve ter visto muitos textos assim, principalmente se voc√™ for mais velho:</p><p><img src=/blog/images/trava/acento.png alt="Erro de encoding no windows 98"></p><p>Esse erro ocorre porque o sistema operacional, o Windows no caso, estava usando o encoding errado. O padr√£o √© ASCII,
mas o Windows 98 usava uma encoding chamada <a href=https://pt.wikipedia.org/wiki/ISO/IEC_8859-1>ISO-8859-1</a>, tamb√©m chamada
Latin-1, para encodificar os caracteres em portugu√™s.</p><p>As pessoas j√° estavam cansadas de problemas como esse, que limitam a comunica√ß√£o. E olha que a diferen√ßa entre o Latin-1
pro ASCII era pequena: em muitos encodings, o que restava de semelhante ao ASCII eram apenas n√∫meros e letras mai√∫sculas.</p><p>O desejo por um padr√£o universal come√ßou, e o Unicode surgiu a partir da√≠.</p><p>[*] Tecnicamente o ASCII vai at√© 127, por motivos que fogem ao assunto desse post.</p><h2 id=utf-8>UTF-8<a href=#utf-8 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>O Unicode representa caracteres em valores chamados de <strong>codepoints</strong>, e eles s√£o representados exclusivamente em hexadecimal.
Esses caracteres v√£o desde letras e n√∫meros em diferentes idiomas at√© <em>kanjis</em>, hieroglifos e emojis.<br>Por exemplo, üí© √© representado pelo codepoint 1F4A9, equivalente a 128169 em decimal.</p><p>Todos os codepoints come√ßam com U seguidos do n√∫mero, ent√£o o codepoint que representa a atual situa√ß√£o do nosso amado pa√≠s
seria escrito U+1F4A9.</p><p>Por√©m, esses <strong>codepoints</strong> n√£o dizem nada sobre como voc√™ os representa na m√°quina. Para isso, existem m√©todos de mapeamento. Os mais
comuns se chamam UTF, ou <em>Unicode Transformation Format</em>, algo como <strong>Formato de Transforma√ß√£o Unicode</strong>, que vai mapear o codepoint em
bytes, para serem usados pelo software.</p><p>O mais popular √© o UTF-8. Nele, voc√™ usa no m√≠nimo um byte e no m√°ximo oito, se eu n√£o me engano. Os bytes que cada codepoint depende do
n√∫mero do codepoint. Felizmente, os 127 primeiros caracteres t√™m o mesmo valor tanto em UTF-8, quanto Unicode e quanto ASCII, ent√£o
n√£o h√° mudan√ßas (por isso que √© t√£o popular). Todos os sistemas operacionais s√£o compat√≠veis e usam UTF-8.</p><p>Existe o UTF-16, onde voc√™ usa entre dois e oito.</p><p>E existe o UTF-32, que voc√™ usa entre quatro e oito, se eu n√£o me engano.</p><p>Muito embora, na pr√°tica, o limite m√°ximo seja quatro.</p><p>Antigamente, o Windows usava um formato chamado <strong>UCS-2</strong>, que usava exatamente dois bytes por codepoint.</p><p>E, sim, letra e codepoint s√£o coisas diferentes. Por exemplo, existem duas formas de escrever a letra <code>√°</code>:</p><ul><li>U+00E1</li><li>U+0061 U+0301.</li></ul><p>Na primeira forma voc√™ usa o codepoint responsavel pela letra <code>√°</code>.</p><p>Na segunda voc√™ usa 2 codepoints: um pra letra <code>a</code> (sem acento) e outro que representa o ato de acentuar o
codepoint anterior.</p><h2 id=navegando-pelo-texto>Navegando pelo texto<a href=#navegando-pelo-texto class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Voc√™ deve estar se perguntando: o que isso tem a ver com o travazap?</p><p>Acalme-se.</p><p>√â importante que voc√™ veja a explica√ß√£o, principalmente na parte que eu falei que, no UTF-8,
<em>voc√™ usa no m√≠nimo um byte e no m√°ximo seis</em>.</p><p>N√£o, o valor de bytes por caractere n√£o √© fixo.</p><p>Por exemplo, se convertermos a frase &ldquo;Luladr√£o roubou meu cora√ß√£o&rdquo; para UTF-8, teremos:
(cada n√∫mero sendo um byte, em hexadecimal)</p><pre tabindex=0><code>00000000  4c 75 6c 61 64 72 c3 a3  6f 2c 20 72 6f 75 62 6f  |Luladr..o, roubo|
          L  u  l  a  d  r  --√£--  o  ,     r  o  u  b  o

00000010  75 20 6d 65 75 20 63 6f  72 61 c3 a7 c3 a3 6f     |u meu cora....o|
          u     m  e  u     c  o   r  a  --√ß-- --√£-- o
</code></pre><p>Perceba que os caracteres com acento ocuparam dois bytes?</p><ul><li><code>√£</code> √© representado pelos bytes C3 e A3 (195 e 163 em decimal).</li><li><code>√ß</code> √© representado pelos bytes C3 e A7 (195 e 167 em decimal).</li></ul><p>Antigamente, em ASCII, um caractere era igual a um byte. Ent√£o, para voc√™, por exemplo, andar
dez caracteres para frente num texto, voc√™ simplesmente pulava dez bytes. Voc√™ nem precisaria
se preocupar no que est√° escrito, j√° que o tamanho √© fixo.</p><p><img src=/blog/images/trava/squid1.png alt="Antigamente, as letras eram assim"></p><p>J√° no UTF-8, voc√™ precisa prestar aten√ß√£o no byte que voc√™ est√° lendo, para ver se o caractere
tem um ou mais bytes.</p><p>Isso torna opera√ß√µes de manipula√ß√£o de texto, como contar letras e palavras, al√©m de descobrir
o tamanho de um peda√ßo de texto em caracteres, relativamente mais dif√≠cil.</p><h2 id=escrita>Escrita<a href=#escrita class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Algo que se torna mais complicado √© desenhar as letras que voc√™ v√™ na tela.</p><p>Antigamente, quando se usava apenas ASCII, o computador ordenava os 256 caracteres do ASCII em uma
lista na mem√≥ria, e usava o valor da letra para se decidir qual caractere desenhar. Por exemplo, se
voc√™ pedisse para ele desenhar o caractere de valor <code>65</code>, o computador iria ver o 65¬∫ caractere da lista,
que seria a letra &ldquo;A&rdquo;, e o desenharia onde voc√™ pediu.</p><p>Como eram apenas 256 valores, n√£o tinha problema em ter uma tabela gigantesca em mem√≥ria.</p><p>Por√©m, a primeira vers√£o do Unicode j√° vinha com dezenas de milhares de &ldquo;caracteres&rdquo; (codepoints, na verdade).
A primeira vers√£o lan√ßou ainda na d√©cada de 90, onde os computadores possu√≠am, em m√©dia, uns 128 MB de mem√≥ria.
Uma simples lista caberia, mas n√£o sobraria muito para outros aplicativos.</p><p>Ent√£o os cientistas da computa√ß√£o inventaram jeitos melhores de guardar esses caracteres na mem√≥ria, e diferentes
formatos de fontes de computador nasceram. Jeitos melhores obviamente aumentaram a velocidade, mas aumentavam
tamb√©m o tamanho desses arquivos, al√©m do consumo de mem√≥ria da m√°quina.</p><p>Por√©m, uma coisa que mudou √© que, antigamente, todos os caracteres tinham um tamanho fixo, de alguns pixels.<br>Por exemplo, se uma letra tem 7 pixels de largura, e voc√™ precisa escrever a palavra <code>PA√áOCA</code>, voc√™ sabe que
precisa reservar <code>7</code> pixels * <code>6</code> caracteres, ou seja, 42 pixels.</p><p><img src=/blog/images/trava/pafoca.png alt="&amp;ldquo;Pa√ßoca&amp;rdquo; escrita em diferentes tipos de letra, para ilustrar os diferentes tamanhos">
&ldquo;Pa√ßoca&rdquo; escrita em diferentes tipos de letra, para ilustrar os diferentes tamanhos</p><p>Agora, um caractere pode ter diferentes tamanhos, ent√£o o programa nunca sabe qual vai ser o tamanho da letra que
ele vai desenhar at√© ele desenhar. Sim, a altura ainda √© conhecida, mas a largura n√£o.</p><h2 id=problemas>Problemas<a href=#problemas class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Ent√£o, n√≥s temos dois problemas:</p><ul><li>Um <strong>caractere</strong> pode ser composto por v√°rios <strong>codepoints</strong>.</li><li>Um <strong>codepoint</strong> pode ser composto por v√°rios <strong>bytes</strong>.</li><li>Um <strong>caractere</strong> pode ter diferentes larguras.</li><li>Al√©m disso, um <strong>caractere</strong> pode ser desenhado de tr√°s pra frente, ou de cima para baixo.</li></ul><p>Identificar caracteres √© dif√≠cil, mas desenh√°-los na tela √© ainda mais.</p><p>O motivo pelo qual isso n√£o parece lento √© que os programas geralmente, na hora de editar texto, ou
deixam quatro bytes por codepoint, fazendo com que seja muito mais f√°cil de navegar, ou usam
algoritmos que permitem navega√ß√£o r√°pida, a custo de mais mem√≥ria consumida.</p><p>Al√©m disso, eles s√≥ desenham os caracteres que v√£o aparecer na tela, o que limita um pouco as coisas.</p><h2 id=voltando-√†-quest√£o>Voltando √† quest√£o.<a href=#voltando-√†-quest√£o class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img src=/blog/images/trava/travazap.jpg alt>
Fonte: radaroeste.com.br</p><p>At√© agora, sabemos que:</p><ul><li>os caracteres podem ocupar mais de um byte.</li><li>cada caractere pode ter diferentes tamanhos.</li><li>a parte mais demorada envolve desenhar o caractere.</li></ul><p>Dito isso, j√° posso explicar como funciona o travazap.</p><p>N√£o, n√£o √© nada a ver com os servidores do whatsapp. O Whatsapp usa uma linguagem chamada <strong>Erlang</strong>
para criar o programa que fica no servidor, enviando as mensagens para os aplicativos lhe mostrarem.<br>Essa linguagem tem um bom suporte a Unicode.</p><p>O aplicativo em si √© feito em Java, se eu n√£o me engano. Java tem um bom suporte a unicode.</p><p>E, para falar a verdade, o tratamento de Unicode j√° √© conhecido faz tempo. Qualquer linguagem de
programa√ß√£o tem fun√ß√µes que lidam com isso.</p><p>O problema est√° na hora de desenhar.</p><p><img src=/blog/images/trava/pombo.png alt></p><p>Isso √© um travazap que eu peguei da internet, inalterado.<br>Ele tem 110 kB.<br>Pode n√£o parecer muito, mas isso s√£o, aproximadamente, 100 mil caracteres.</p><p>Voc√™ j√° pode perceber que tem algo errado, j√° que os travazaps n√£o parecem ser t√£o grandes.
No m√°ximo eles t√™m uma tela ou duas. Isso n√£o d√° cem mil caracteres nunca, nem na menor
fonte poss√≠vel que voc√™ pode configurar no celular.</p><p>O problema, na verdade, est√° em <em>desenhar</em>.</p><p>A maior parte do travazap √© composta por esses codepoints aqui:</p><ul><li><code>U+2009</code></li><li><code>U+200A</code></li></ul><p>Se voc√™ souber ingl√™s, vai ver que <a href=https://unicode-explorer.com/c/2009>o nome do primeiro codepoint</a>
√© algo como &ldquo;ESPA√áO PEQUENO&rdquo;, e <a href=https://unicode-explorer.com/c/200A>o nome do segundo</a>
√© algo como &ldquo;ESPA√áO DO TAMANHO DE UM FIO DE CABELO&rdquo;.</p><p>O <code>2009</code> √© o segundo menor espa√ßo dispon√≠vel, medindo algo como 3 pixels. O <code>200A</code> √© ainda menor do que
isso. Lembrando que as telas de celular de hoje em dia possuem algo como 720 pixels de largura[2],
ent√£o cabem uns 300 caracteres desses por linha.</p><p>Esses dois caracteres n√£o s√£o muito dif√≠ceis de serem desenhados, mas, ainda assim, o WhatsApp precisa
desenh√°-los um a um. E, como os caracteres s√£o bem pequenos, voc√™ precisa desenhar muitos deles
para chegar at√© o final da tela.</p><p>Ao contr√°rio do seu navegador, Chrome ou Firefox, que j√° √© otimizado para lidar com muito texto (
lembrando que, tecnicamente, s√£o <strong>100 mil caracteres de uma vez</strong> ), o WhatsApp n√£o √©, e ele
acaba travando.</p><p>Muitos travazaps cont√©m <em>codepoints</em> que mudam a dire√ß√£o do texto, o que tamb√©m afeta a velocidade
de desenho, j√° que voc√™ precisa calcular a medida da letra de tr√°s para frente, e ir andando
pelo texto at√© achar o <em>codepoint</em> que volta a dire√ß√£o do texto ao normal.</p><p><strong>Fato curioso:</strong> o travazap n√£o funciona com SMS da mesma forma que com o WhatsApp.<br>Sim, o SMS suporta Unicode, mas ele tem um limite <em>em bytes</em>, e esse limite √© relativamente
pequeno. Ent√£o voc√™ n√£o vai ver tantos caracteres. <em>MASSSS</em>, voc√™ vai receber muitas mensagens
de uma vez, umas mil, uma atr√°s da outra.<br>√â <em>isso</em> √© o qe pode travar o seu celular</p><hr><p>[2] 720 pixels <em>virtuais</em>. Na verdade, a tela tem, no m√≠nimo, o dobro dessa resolu√ß√£o, mas ela √©
mais usada pelo sistema pra suavizar as bordas das letras e melhorar a defini√ß√£o das imagens.\
Para o aplicativo, √© uma tela de 720 pixels.</p><hr><p>Pronto, TravaZap explicado!</p><p>Na parte 2, que eu ainda vou escrever, eu vou falar mais ou menos como funciona o TravaLoL novo.
Como eu ainda estou pesquisando, vai demorar um pouco mais.</p></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-arthurmco-github-io-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__dates><h4>Archive</h4><ul id=date-archive><li><a href=https://arthurmco.github.io/blog/archive/202208>August 2022</a> (3)</li><li><a href=https://arthurmco.github.io/blog/archive/202207>July 2022</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202205>May 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202204>April 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202203>March 2022</a> (2)</li></optgroup><li><a href=https://arthurmco.github.io/blog/archive/202109>September 2021</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202104>April 2021</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202102>February 2021</a> (3)</li></optgroup></li></div><div class=footer__inner><div class=copyright><span>¬© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a> :: forked by <a href=https://twitter.com/usrbinarthur>arthurmco</a></span></div></div></footer><script src=https://arthurmco.github.io/blog/assets/main.js></script>
<script src=https://arthurmco.github.io/blog/assets/prism.js></script></div></body></html>