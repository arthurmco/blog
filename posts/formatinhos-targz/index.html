<!doctype html><html lang=en><head><title>Formatinhos: TAR.GZ :: Blog do Arthur M.</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="O segundo formato da série é um dos formatos mais tradicionais de arquivamento e compressão
dos Unixes, o `tar`, mais especificamente a sua variante comprimida, `.tar.gz`.

O parsing desse formato, surpreendentemente, é extremamente simples, o que me faz pensar
o motivo de eu não ter aberto a série com ele.
"><meta name=keywords content="formatinhos,arquivamento,compactação,tar,gzip,gnu"><meta name=robots content="noodp"><link rel=canonical href=https://arthurmco.github.io/blog/posts/formatinhos-targz/><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/style.css><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/red.css><link rel=apple-touch-icon href=https://arthurmco.github.io/blog/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://arthurmco.github.io/blog/img/favicon/red.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Formatinhos: TAR.GZ"><meta property="og:description" content="O segundo formato da série é um dos formatos mais tradicionais de arquivamento e compressão
dos Unixes, o `tar`, mais especificamente a sua variante comprimida, `.tar.gz`.

O parsing desse formato, surpreendentemente, é extremamente simples, o que me faz pensar
o motivo de eu não ter aberto a série com ele.
"><meta property="og:url" content="https://arthurmco.github.io/blog/posts/formatinhos-targz/"><meta property="og:site_name" content="Blog do Arthur M."><meta property="og:image" content="https://arthurmco.github.io/blog/img/favicon/red.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-08-19 23:22:11 -0300 -0300"></head><body class=red><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://arthurmco.github.io/blog/><div class=logo>Blog do Arthur M.</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://arthurmco.github.io/blog/posts/formatinhos-targz/>Formatinhos: TAR.GZ</a></h1><div class=post-meta><span class=post-date>2022-08-19
[Modificado em: 2022-08-19]</span>
<span class=post-author>:: Arthur Mendes</span>
<span class=post-reading-time><br>8
minutos
estimados de leitura</span></div><span class=post-tags>#<a href=https://arthurmco.github.io/blog/tags/code/>code</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/formats/>formats</a>&nbsp;</span><div class=post-content><div><p>O <code>tar</code> é o formato mais tradicional de arquivamento do universo Unix, sendo usado desde o final da
década de 70, muito antes do ZIP sequer ser pensado.</p><p>O <code>tar</code> é diferente de outros formatos de arquivamento porque ele não comprime arquivos individualmente.
Todos o arquivo tar é comprimido junto. Para extrair os arquivos, você deve primeiro descomprimir o
arquivo <code>.tar</code> inteiro.</p><p>Para identificar o formato de compressão, você adiciona um sufixo no arquivo. Os formatos e sufixos
suportados são:</p><table><thead><tr><th>Sufixo</th><th>Formato</th></tr></thead><tbody><tr><td>‘.gz’</td><td>gzip</td></tr><tr><td>‘.tgz’</td><td>gzip</td></tr><tr><td>‘.taz’</td><td>gzip</td></tr><tr><td>‘.Z’</td><td>compress</td></tr><tr><td>‘.taZ’</td><td>compress</td></tr><tr><td>‘.bz2’</td><td>bzip2</td></tr><tr><td>‘.tz2’</td><td>bzip2</td></tr><tr><td>‘.tbz2’</td><td>bzip2</td></tr><tr><td>‘.tbz’</td><td>bzip2</td></tr><tr><td>‘.lz’</td><td>lzip</td></tr><tr><td>‘.lzma’</td><td>lzma</td></tr><tr><td>‘.tlz’</td><td>lzma</td></tr><tr><td>‘.lzo’</td><td>lzop</td></tr><tr><td>‘.xz’</td><td>xz</td></tr><tr><td>‘.zst’</td><td>zstd</td></tr><tr><td>‘.tzst’</td><td>zstd</td></tr></tbody></table><p>O sufixo mais visto e o mais suportado é o .gz. Por isso que você vê muito <code>.tar.gz</code>.</p><h1 id=o-formato>O formato<a href=#o-formato class=hanchor arialabel=Anchor>&#8983;</a></h1><p>O lado bom do arquivo .tar é que não existem valores binários: os valores binários dele estão nos
arquivos, não nos metadados.</p><p>Todos os números são salvos em octal. Por exemplo, se você ver um <code>10</code> no arquivo, significa que
o valor que está ali é 8, pois <code>10</code> em octal é 8 em decimal. Assim como <code>11</code>=9, <code>12</code>=10, <code>13</code>=11,
<code>17</code>=15 e <code>20</code>=16.</p><p>As <em>strings</em> têm um tamanho fixo. Se o tamanho delas no arquivo for menor que o tamanho fixo, vários
bytes <code>0</code> são adicionados até chegarem nesse tamanho.</p><p>O arquivo tar é dividido em blocos. Cada bloco possui 512 bytes. Esse também é o tamanho do header
contendo os metadados dos arquivos.</p><p>O arquivo já começa com o header do primeiro arquivo:</p><pre tabindex=0><code>00000000  67 72 61 70 68 69 63 61  6c 73 62 6f 75 6e 64 69  |graphicalsboundi|
00000010  6e 67 2e 72 73 00 00 00  00 00 00 00 00 00 00 00  |ng.rs...........|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000060  00 00 00 00 30 30 30 30  37 37 37 00 30 30 30 31  |....0000777.0001|
00000070  37 35 30 00 30 30 30 31  37 35 30 00 30 30 30 30  |750.0001750.0000|
00000080  30 30 30 37 36 30 33 00  31 34 32 37 33 30 30 32  |0007603.14273002|
00000090  32 37 35 00 30 31 35 37  37 34 00 20 30 00 00 00  |275.015774. 0...|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000100  00 75 73 74 61 72 20 20  00 61 72 74 68 75 72 6d  |.ustar  .arthurm|
00000110  63 6f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |co..............|
00000120  00 00 00 00 00 00 00 00  00 61 72 74 68 75 72 6d  |.........arthurm|
00000130  63 6f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |co..............|
00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre><table><thead><tr><th>Posição</th><th>Tamanho</th><th>Campo</th><th>Valor</th></tr></thead><tbody><tr><td><code>0x0 (0)</code></td><td>100</td><td>name</td><td><code>graphicalsbounding.rs</code></td></tr><tr><td><code>0x64 (100)</code></td><td>8</td><td>mode</td><td><code>0000777</code></td></tr><tr><td><code>0x6c (108)</code></td><td>8</td><td>uid</td><td><code>0001750</code></td></tr><tr><td><code>0x74 (116)</code></td><td>8</td><td>gid</td><td><code>0001750</code></td></tr><tr><td><code>0x7c (124)</code></td><td>12</td><td>size</td><td><code>00000007603</code></td></tr><tr><td><code>0x88 (136)</code></td><td>12</td><td>mtime</td><td><code>14273002275</code></td></tr><tr><td><code>0x94 (148)</code></td><td>8</td><td>chksum</td><td><code>015774</code></td></tr><tr><td><code>0x9c (156)</code></td><td>1</td><td>typeflag</td><td><code>30</code> = <code>REGTYPE</code></td></tr><tr><td><code>0x9d (157)</code></td><td>100</td><td>linkname</td><td><code></code></td></tr><tr><td><code>0x101 (257)</code></td><td>6</td><td>magic</td><td><code>ustar</code></td></tr><tr><td><code>0x107 (263)</code></td><td>2</td><td>version</td><td><code>0x20 0x00</code></td></tr><tr><td><code>0x109 (265)</code></td><td>32</td><td>uname</td><td><code>arthurmco</code></td></tr><tr><td><code>0x129 (297)</code></td><td>32</td><td>gname</td><td><code>arthurmco</code></td></tr><tr><td><code>0x149 (329)</code></td><td>8</td><td>devmajor</td><td><code></code></td></tr><tr><td><code>0x151 (337)</code></td><td>8</td><td>devminor</td><td><code></code></td></tr><tr><td><code>0x159 (345)</code></td><td>155</td><td>prefix</td><td><code></code></td></tr></tbody></table><p>Como eu falei, <strong>todos os números estão em formato octal</strong>.</p><p>Depois desse header, no próximo bloco está o conteúdo do arquivo.</p><p>Quando o arquivo termina, o header começa no próximo bloco, no próximo byte múltiplo de 512.</p><p>Ou seja, se o arquivo acabar no byte 5090, o header só vai começar no byte 5120, já que é o próximo
múltiplo de 512.</p><p>Para sinalizar o final do arquivo, dois blocos vazios (ou seja, cheios de bytes 0) são escritos.</p><p>O arquivo <code>tar</code> é identificado pelo valor no campo <code>magic</code>, ou seja <code>ustar</code>. Existem mais tipos de
arquivos tar, e eles serão discutidos nas próximas partes.</p><p>O checksum (escrito no campo <code>chksum</code>) é calculado somando todos os bytes do header. Os bytes que
estariam no checksum são substituídos, na função do cálculo, por espaços (<code> </code>, byte 32). O resultado
é escrito no campo (no caso da escrita) ou comparado com o valor do campo (no caso da leitura)</p><p><code>uname</code> e <code>gname</code> são os nomes do usuário e do grupo que criaram o arquivo. <code>uid</code> e <code>gid</code> são os IDs
de usuário e grupo.</p><p><code>mtime</code> é a data da última modificação do arquivo, ou de criação se o arquivo nunca foi alterado. O
valor é a quantidade de segundos desde 01/01/1970.</p><p><code>name</code> é o nome do arquivo. Se ele é um link que aponta pra outro arquivo, o nome desse arquivo
vai estar em <code>linkname</code>.</p><p><code>devmajor</code> e <code>devminor</code> só fazem sentido se o arquivo for um device, tipo aqueles arquivos que
estão dentro da pasta <code>/dev</code> nos linuxes e unixes da vida.</p><h2 id=códigos>Códigos<a href=#códigos class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Inicialmente, definiremos os valores possíveis nos campos <code>mode</code> e <code>typeflag</code>:</p><div class=collapsable-code><input id=692187543 type=checkbox>
<label for=692187543><span class=collapsable-code__language>python</span>
<span class=collapsable-code__title>tarfile.py: Estruturas possíveis nos valores</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-python><code>
from enum import Enum, IntFlag

# Isso são flags.
# Significa que mais de um valor pode ser possível aqui.
class FileMode(IntFlag):
    # O modo do arquivo
    # Quando você dá `ls -l` no terminal, tem um monte de rwxrwxrwx. 
    # Isso é codificado aqui.&#39;
    # O significado está claro se você manja um pouco de inglês. 
    # Se não, separa as duas palavras e joga no google tradutor que vai estar 
    # correto.

    OtherExec = 1
    OtherWrite = 2
    OtherRead = 4

    GroupExec = 8
    GroupWrite = 16
    GroupRead = 32

    OwnerExec = 64
    OwnerWrite = 128
    OwnerRead = 256

    SetGid = 1024
    SetUid = 2048

class FileType(Enum):
    ## O tipo de arquivo

    # Um arquivo comum
    Regular = 0            

    # Um link pra outro arquivo
    Link = 1

    # Um link simbólico. Esse valor está depreciado e não é usado
    Symlink = 2

    # Se você sabe o que são essas duas coisas abaixo, então você sabe o que 
    # significa tudo aqui nesse enum, e não está nem lendo esses comentários.
    CharacterDevice = 3
    BlockDevice = 4

    # Representa uma pasta. Uma coisa engraçada é que, dentro do arquivo tar, 
    # logo depois da pasta,  vêm os arquivos que estão dentro dela. 
    # Isso pode ser útil pra você.
    Directory = 5

    # Se você sabe o que é isso daqui, então você nem precisa desses comentários
    FIFOPipe = 6

    # Campo reservado.
    Reserved = 7

    # Como converter do valor do arquivo pro valor do enum
    # O `val` é o caractere que vem do arquivo.
    @staticmethod
    def from_value(val):
        selections = {
            &#34;0&#34;: FileType.Regular,
            &#34;\0&#34;: FileType.Regular,
            &#34;1&#34;: FileType.Link,
            &#34;2&#34;: FileType.Symlink,
            &#34;3&#34;: FileType.CharacterDevice,
            &#34;4&#34;: FileType.BlockDevice,
            &#34;5&#34;: FileType.Directory,
            &#34;6&#34;: FileType.FIFOPipe,
            &#34;7&#34;: FileType.Reserved
        }

        return selections.get(val, FileType.Reserved)
</code></pre></div><p>Algumas funções auxiliares, que vão ajudar a ler o arquivo<div class=collapsable-code><input id=784392156 type=checkbox>
<label for=784392156><span class=collapsable-code__language>python</span>
<span class=collapsable-code__title>tarfile.py: Funções auxiliares</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-python><code>
# Isso aqui embaixo vem no final:

# Lê uma string do arquivo
def read_string(value):
    return value.decode(&#39;utf-8&#39;).rstrip(&#39;\x00 &#39;)

# Lê um número do arquivo. Ele está em octal, então devemos converter.
def read_number(value, default=None):
    try:
        return int(read_string(value), base=8)
    except ValueError:
        return default

</code></pre></div></p><p>Depois, vamos ler o arquivo TAR:<div class=collapsable-code><input id=439521768 type=checkbox>
<label for=439521768><span class=collapsable-code__language>python</span>
<span class=collapsable-code__title>tarfile.py: Estruturas do arquivo tar</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-python><code>
## Coloque isso no começo do arquivo, antes do `from enum`
from dataclasses import dataclass

## Isso aqui embaixo vem no final:

# O tamanho do bloco:
BLOCK_SIZE = 512

@dataclass
class TarFile:
    # Você já conhece esses campos :)
    name: str
    mode: FileMode
    uid: int
    gid: int
    size: int
    mtime: dt.datetime
    checksum: int
    typeflag: FileType
    linkname: str
    magic: str
    version: int
    uname: str
    gname: str
    devmajor: int
    devminor: int
    prefix: str

    # O offset do arquivo que segue esse header, pra gente poder ler ele
    # depois
    offset: int

    # O offset do próprio header.
    header: int

    def read_file(self, fileobject):
        # Lê o conteúdo do arquivo que esse header representa
        tell = fileobject.tell()

        fileobject.seek(self.offset)
        data = fileobject.read(self.size)
        fileobject.seek(tell)

        return data

    def get_header_offset(self):
        return self.offset - BLOCK_SIZE

    def verify_checksum(self, fileobject):
        # Verifica o checksum desse header, pra ver se ele é válido ou não.
        tell = fileobject.tell()

        fileobject.seek(self.get_header_offset())
        data = fileobject.read(BLOCK_SIZE)

        checksum = sum([v if i not in range(148, 156) else ord(&#39; &#39;)
                        for i, v in enumerate(data)])

        fileobject.seek(tell)

        return checksum == self.checksum

    @staticmethod
    def from_file(fileobject):
        # Lê um arquivo.
        #
        # Esse `fileobject` é um objeto de arquivo, gerado pelo método `open`, ou
        # por qualquer método que represente um arquivo, como `GzipFile` e outros
        # similares.
        #
        # Esse método vai alterar o fileobject, fazendo ele apontar pro próximo 
        # bloco, que na maior parte das vezes vai ser o conteúdo do arquivo.

        offset = fileobject.tell()

        name = read_string(fileobject.read(100))
        if name == &#34;&#34;:
            return None

        mode = FileMode(read_number(fileobject.read(8)))
        uid = read_number(fileobject.read(8))
        gid = read_number(fileobject.read(8))
        size = read_number(fileobject.read(12))
        mtime = dt.datetime.fromtimestamp(read_number(fileobject.read(12)))
        checksum = read_number(fileobject.read(8))
        typeflag = FileType.from_value(read_string(fileobject.read(1)))
        linkname = read_string(fileobject.read(100))

        magic = read_string(fileobject.read(6))
        version = read_number(fileobject.read(2), 0)

        if not magic.startswith(&#34;ustar&#34;):
            raise ValueError(f&#34;Invalid header at offset {offset}&#34;)

        uname = read_string(fileobject.read(32))
        gname = read_string(fileobject.read(32))
        devmajor = read_number(fileobject.read(8))
        devminor = read_number(fileobject.read(8))
        prefix = fileobject.read(155)

        pad = fileobject.read(12)

        return TarFile(name, mode, uid, gid, size, mtime, checksum, typeflag, 
                       linkname, magic, version, uname, gname, devmajor, devminor,
                       prefix, offset &#43; BLOCK_SIZE, offset)

</code></pre></div></p><p>Essa função acima só vai ler o header. Depois do header vem o arquivo.</p><p>E é isso. O necessário para ler o formato está descrito</p><p>Se você quiser, você pode transformar esse código que eu mostrei em um parser de arquivo <code>.tar</code>:</p><ul><li>Você pode simplesmente usar <code>open</code> para ler um arquivo <code>tar</code> puro. O método <code>TarFile.from_file</code>
aceita um objeto de arquivo que a função <code>open</code> retorna</li><li>Para ler um arquivo <code>.tar.gz</code>, use a classe <code>GzipFile</code> para ler o arquivo, já que esse é o
formato que o tar está comprimido</li><li>Outros formatos têm outras bibliotecas de suporte. Se você quiser, pode suportá-las.</li><li>Lembre-se que dois blocos vazios, cheios de 0, identificam o final do arquivo&mldr;</li><li>Converta esse código para a sua linguagem favorita</li></ul><h1 id=referências>Referências:<a href=#referências class=hanchor arialabel=Anchor>&#8983;</a></h1><ul><li><a href=https://www.gnu.org/software/tar/manual/html_node/Standard.html>https://www.gnu.org/software/tar/manual/html_node/Standard.html</a></li><li><a href=https://www.gnu.org/software/tar/manual/html_chapter/Formats.html#Compression>https://www.gnu.org/software/tar/manual/html_chapter/Formats.html#Compression</a></li></ul></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-arthurmco-github-io-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__dates><h4>Archive</h4><ul id=date-archive><li><a href=https://arthurmco.github.io/blog/archive/202209>September 2022</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202208>August 2022</a> (7)</li><li><a href=https://arthurmco.github.io/blog/archive/202207>July 2022</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202205>May 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202204>April 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202203>March 2022</a> (2)</li></optgroup><li><a href=https://arthurmco.github.io/blog/archive/202109>September 2021</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202104>April 2021</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202102>February 2021</a> (3)</li></optgroup></li></div><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a> :: forked by <a href=https://twitter.com/usrbinarthur>arthurmco</a></span></div></div></footer><script src=https://arthurmco.github.io/blog/assets/main.js></script>
<script src=https://arthurmco.github.io/blog/assets/prism.js></script></div></body></html>