<!doctype html><html lang=en><head><title>Formatinhos: BMP - Parte 3: Layout do pixel :: Blog do Arthur M.</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="O terceiro episódio da série de um dos formatos de imagens historicamente mais fáceis
de parsear.

Nesse post você vai conseguir ler bitmaps com diferentes layouts do pixel.
"><meta name=keywords content="formatinhos,bmp,imagem,bitmap,microsoft"><meta name=robots content="noodp"><link rel=canonical href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-3/><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/style.css><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/red.css><link rel=apple-touch-icon href=https://arthurmco.github.io/blog/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://arthurmco.github.io/blog/img/favicon/red.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Formatinhos: BMP - Parte 3: Layout do pixel"><meta property="og:description" content="O terceiro episódio da série de um dos formatos de imagens historicamente mais fáceis
de parsear.

Nesse post você vai conseguir ler bitmaps com diferentes layouts do pixel.
"><meta property="og:url" content="https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-3/"><meta property="og:site_name" content="Blog do Arthur M."><meta property="og:image" content="https://arthurmco.github.io/blog/img/favicon/red.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-08-15 08:59:20 -0300 -0300"></head><body class=red><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://arthurmco.github.io/blog/><div class=logo>Blog do Arthur M.</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-3/>Formatinhos: BMP - Parte 3: Layout do pixel</a></h1><div class=post-meta><span class=post-date>2022-08-15
[Modificado em: 2022-08-15]</span>
<span class=post-author>:: Arthur Mendes</span>
<span class=post-reading-time><br>5
minutos
estimados de leitura</span></div><span class=post-tags>#<a href=https://arthurmco.github.io/blog/tags/code/>code</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/formats/>formats</a>&nbsp;</span><div class=post-content><div><p>Na <a href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-1/>primeira parte</a>, aprendemos o básico sobre como
ler um arquivo de bitmap.</p><p>Na <a href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/>segunda parte</a>, aprendemos a ler bitmaps com
diferentes densidades de pixel.</p><p>Agora, iremos ver diferentes densidades de pixel.</p><h1 id=densidades-de-pixel>Densidades de pixel<a href=#densidades-de-pixel class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Por padrão, o arquivo de bitmap possui uma densidade e organização padrão para o pixel.<br>As funções <code>getColors</code> da parte anterior mostram isso.</p><p>Porém, alguns programas podem mudar essa ordem, por exemplo, para otimizar certas cores. O arquivo
que tem a &ldquo;compressão&rdquo; <code>BITFIELDS</code> possui essa capacidade.</p><p>Essa ordem é especificada em um tipo de valor chamado de &lsquo;bitmask&rsquo;.</p><h2 id=bitmask>Bitmask<a href=#bitmask class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Vem do inglês e significa, literalmente, <em>máscara de bits</em>. É basicamente um jeito de &ldquo;cortar&rdquo; um
valor: bits 1 são mantidos e bits 0 sao cortados. Por exemplo:</p><blockquote><p>Valor: 42069<br>Máscara: 496</p></blockquote><p>Convertemos esses valores para binário</p><p><code>Valor__: 1010 0100 0101 0101</code><br><code>Máscara: 0000 0001 1111 0000</code></p><p>Fazemos uma operação AND. Isso significa que, se os dois valores forem <code>1</code>, o resultado será <code>1</code>,
do contrário o resultado será <code>0</code>.</p><p><code>Valor resultante: 0000 0000 0101 0000</code></p><p>Convertemos de volta para decimal:</p><blockquote><p>Valor resultante: 80</p></blockquote><p>Além disso, iremos fazer mais uma operação, a operação de shifting. Contamos quantos bits temos
até o primeiro valor 1 e shiftamos esse valor para a direita.</p><p>No caso, o valor é 4.</p><p><code>Valor final: 0000 0000 0101 0000</code> &#187; 4 = <code>0000 0000 0000 0101</code></p><blockquote><p>Valor final: 5</p></blockquote><h2 id=leitura>Leitura<a href=#leitura class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Agora que você já sabe como a operação de bitmask funciona, iremos ler esse valor.</p><p>Logo depois do header DIB (lembre-se da parte 1), se a compressão for <code>BITFIELDS</code>, temos quatro
campos a mais:</p><pre tabindex=0><code>00000020  00 00 00 00 10 00  d7 0d  00 00 d7 0d 00 00 [00 00  |................|
00000030  00 00 00 00 00 00  00 00  ff 00 00 ff 00 00  ff 00  |................|
00000040  00 00 00 00 00 ff] 00 00  00 00 00 00 00 00  00 00  |................|
00000050  00 00 00 00 00 00  00 00  00 00 00 00 00 00  00 00  |................|
</code></pre><table><thead><tr><th>Posição</th><th>Tamanho</th><th>Campo</th><th>Valor</th></tr></thead><tbody><tr><td><em><code>0x20 (32)</code></em></td><td><em>4</em></td><td><em>biClrUsed</em></td><td><em><code>0</code></em></td></tr><tr><td><em><code>0x24 (36)</code></em></td><td><em>4</em></td><td><em>biClrImportant</em></td><td><em><code>0</code></em></td></tr><tr><td>0x28 (40)</td><td>4</td><td>bV5RedMask</td><td><code>00 00 ff 00</code> (0x00ff_0000)</td></tr><tr><td>0x2c (44)</td><td>4</td><td>bV5GreenMask</td><td><code>00 ff 00 00</code> (0x0000_ff00)</td></tr><tr><td>0x30 (48)</td><td>4</td><td>bV5BlueMask</td><td><code>ff 00 00 00</code> (0x0000_00ff)</td></tr><tr><td>0x34 (52)</td><td>4</td><td>bV5AlphaMask</td><td><code>00 00 00 ff</code> (0xff00_0000)</td></tr></tbody></table><p>O tamanho desses valores é sempre 32 bits, mas ele é usado para extrair valores em densidades
de bits menores. Você simplesmente ignora os outros bits.</p><p>O <code>red mask</code> é usado para extrair o vermelho, o <code>green</code> é usado pra extrair o verde, o <code>blue</code> é
usado para extrair o azul e o <code>alpha</code> é usado para extrair o canal de transparência.</p><p>Por padrão, cada pixel é organizado desse jeito:</p><p>16 bits:</p><pre tabindex=0><code>15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
-  R  R  R  R  R  G  G  | G  G  G  B  B  B  B  B
</code></pre><p>24 bits:</p><pre tabindex=0><code>------------------------| 23 22 21 20 19 18 17 16
-  -  -  -  -  -  -  -  | R  R  R  R  R  R  R  R

15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
G  G  G  G  G  G  G  G  | B  B  B  B  B  B  B  B
</code></pre><p>32 bits:</p><pre tabindex=0><code>31 30 29 28 27 26 25 24 | 23 22 21 20 19 18 17 16
-  -  -  -  -  -  -  -  | R  R  R  R  R  R  R  R

15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
G  G  G  G  G  G  G  G  | B  B  B  B  B  B  B  B
</code></pre><p>Traduzir isso para bitmasks será um exercício para o leitor.</p><p>Em código, a leitura e interpretação das bitmasks é a seguinte:</p><div class=collapsable-code><input id=798435612 type=checkbox>
<label for=798435612><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>bmp.js: Parsing da máscara de bits</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
function openDIBHeader(buffer) {
    /* ... */
    const dibHeader = {
        compression: parseCompression(get32(buffer, 30)),
        bitmapSize: get32(buffer, 34),
        horizontalRes: get32(buffer, 38),
        verticalRes: get32(buffer, 42),
        paletteColors: get32(buffer, 46),
        importantColors: get32(buffer, 50)
    };

    /* adicione essa linha aqui: */
    const headerBitfields = {
        red: get32(buffer, 54),
        green: get32(buffer, 58),
        blue: get32(buffer, 62),
        alpha: get32(buffer, 66),
    }
    /* é esse código acima que você tem que botar */

    return {
        size: headerSize,
        ...baseHeader,
        ...(headerSize &gt;= 40 ? dibHeader : {}),
        // isso aqui embaixo também: 
        bitfields: (dibHeader.compression === &#39;bitfields&#39; ? headerBitfields : null)
    }
}

/* Pega a bitmask e te diz quanto você precisa shiftar e em qual valor
 * você precisa dar AND para ter o valor de cor baseado na bitmask
 *
 * Não é o jeito mais otimizado de fazer isso, mas é um jeito correto.
 */
function bitmaskIntoShiftAndMask(bitmask) {
    let shift = 0;
    let mask = bitmask;

    while (!(mask &amp; 0x1)) {
        if (mask === 0)
            break;

        mask = mask &gt;&gt;&gt; 1;
        shift&#43;&#43;;
    }

    return { shift, mask };
}

/* Pega a bitmask dos quatro canais */
function getBitmasks(bitfields) {
    if (!bitfields)
        return null;

    return {
        r: bitmaskIntoShiftAndMask(bitfields.red),
        g: bitmaskIntoShiftAndMask(bitfields.green),
        b: bitmaskIntoShiftAndMask(bitfields.blue),
        a: bitmaskIntoShiftAndMask(bitfields.alpha),
    }
}

/* Meio auto-explicativo essa :P */
function getValueFromBitmask(value, { shift, mask }) {
    return (value &gt;&gt;&gt; shift) &amp; mask;
}

/**
 * Vou deixar como exemplo uma das densidades de cor aqui, para você ver como 
 * extrair a cor do pixel baseados nas bitmasks.
 *
 * O parâmetro bitmask tem como formato o resultado da função getBitmasks()
 *
 * As outras densidades ficam a seu cargo implementar, se você quiser
 */
function getColors32(y, x, buffer, pixelpos, bitmask) {
    const value = get32(buffer, pixelpos(y, x));
    const bits = getBitmasks(bitmask);
 
    const r = getValueFromBitmask(value, bits.r);
    const g = getValueFromBitmask(value, bits.g);
    const b = getValueFromBitmask(value, bits.b);
    
    // Se não tiver alfa, faz ele ser completamente opaco.
    const a = bits.a.mask ? getValueFromBitmask(value, bits.a) : 0xff;

    // format RGBA
    return [
        r, g, b, a
    ];
}

</code></pre></div><hr><p>E concluimos esse formato. Por enquanto.</p><p>O próximo formato sai daqui a alguns dias, e o repositório com um parser BMP em Javascript
sai também daqui a uns dias</p><p>Vou começar a estudar a compressão RLE, mas ela vai vir mais como um bônus.</p></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-arthurmco-github-io-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__dates><h4>Archive</h4><ul id=date-archive><li><a href=https://arthurmco.github.io/blog/archive/202208>August 2022</a> (7)</li><li><a href=https://arthurmco.github.io/blog/archive/202207>July 2022</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202205>May 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202204>April 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202203>March 2022</a> (2)</li></optgroup><li><a href=https://arthurmco.github.io/blog/archive/202109>September 2021</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202104>April 2021</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202102>February 2021</a> (3)</li></optgroup></li></div><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a> :: forked by <a href=https://twitter.com/usrbinarthur>arthurmco</a></span></div></div></footer><script src=https://arthurmco.github.io/blog/assets/main.js></script>
<script src=https://arthurmco.github.io/blog/assets/prism.js></script></div></body></html>