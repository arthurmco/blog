<!doctype html><html lang=en><head><title>Criando um 'crash handler' Part 1 :: Blog do Arthur M.</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Sabe aquelas telas que abarecem quando um programa ou jogo crasha e fecha? _BugSplat_, a do Firefox, do Chrome? Bem, descobri como elas foram feitas. Vou tentar fazer uma igual e mostrar pra vocês como eu fiz Nessa primeira parte eu vou mostrar como eu fiz isso no Linux "><meta name=keywords content="devlog,talk"><meta name=robots content="noodp"><link rel=canonical href=https://arthurmco.github.io/blog/posts/crash-handler-part-1/><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/style.css><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/red.css><link rel=apple-touch-icon href=https://arthurmco.github.io/blog/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://arthurmco.github.io/blog/img/favicon/red.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Criando um 'crash handler' Part 1"><meta property="og:description" content="Sabe aquelas telas que abarecem quando um programa ou jogo crasha e fecha? _BugSplat_, a do Firefox, do Chrome? Bem, descobri como elas foram feitas. Vou tentar fazer uma igual e mostrar pra vocês como eu fiz Nessa primeira parte eu vou mostrar como eu fiz isso no Linux "><meta property="og:url" content="https://arthurmco.github.io/blog/posts/crash-handler-part-1/"><meta property="og:site_name" content="Blog do Arthur M."><meta property="og:image" content="https://arthurmco.github.io/blog/images/cover-crash-handler.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-04-26 21:32:29 -0300 -0300"></head><body class=red><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://arthurmco.github.io/blog/><div class=logo>Blog do Arthur M.</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://arthurmco.github.io/blog/posts/crash-handler-part-1/>Criando um &lsquo;crash handler&rsquo; Part 1</a></h1><div class=post-meta><span class=post-date>2021-04-26
[Modificado em: 2021-04-26]</span>
<span class=post-author>:: Arthur Mendes</span>
<span class=post-reading-time><br>6
minutos
estimados de leitura</span></div><span class=post-tags>#<a href=https://arthurmco.github.io/blog/tags/gamedev/>gamedev</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/c++/>c++</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/crash-handler/>crash-handler</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/sysv/>sysv</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/abi/>abi</a>&nbsp;</span>
<img src=https://arthurmco.github.io/blog/images/cover-crash-handler.png class=post-cover alt="Criando um 'crash handler' Part 1" title="Cover Image"><div class=post-content><div><p>Sabe aquelas telas que abarecem quando um programa ou jogo crasha e fecha? <em>BugSplat</em>,
a do Firefox, do Chrome? Bem, descobri como elas funcionam. Vou tentar fazer uma igual
e mostrar pra vocês como eu fiz.</p><p>Uma coisa que eu descobri é que esse tipo de programa é extremamente dependente de arquitetura de
processador e de sistema operacional; portanto nessa primeira parte eu vou mostrar o funcionamento,
e como fazer um desses <em>crash handlers</em> no Linux</p><blockquote><p>Um aviso: Isso aqui só vai funcionar se o seu software não tiver nenhum tipo de runtime (ou seja,
Java e .NET&mldr;), porque iremos mexer diretamente com a pilha de execução do processador.</p></blockquote><h1 id=como-um-crash-handler-funciona>Como um crash handler funciona<a href=#como-um-crash-handler-funciona class=hanchor arialabel=Anchor>&#8983;</a></h1><p>O crash handler é um programa que faz algo (a parte de <em>handle</em>) quando um programa <em>crasha</em>, daí o nome.</p><p>Geralmente esses programas pegam algumas informações importantes do processo (como a <code>call stack</code>, ou
pilha de chamadas, que é uma pilha onde a função no topo é a função mais recente, a função abaixo é a
função que chamou a primeira, a terceira função é a que chamou a segunda&mldr;), e mandam para algum
servidor para análise.</p><p>Um exemplo de call stack está abaixo.
<img src=/blog/images/03-call-stack-example.png alt="Um exemplo de &amp;lsquo;call stack&amp;rsquo; no GNU Debugger"></p><p>Em azul estão os endereços de memória; no caso do primeiro da lista é o endereço de memória onde
o processador estava (o famoso <em>program counter</em>, ou <em>instruction pointer</em>), no caso dos restantes
é o endereço de memória aonde o processador vai retornar quando ele sair da função acima.</p><blockquote><p>Por exemplo, o endereço de memória do segundo item da lista é aonde o processador vai retornar quando
ele terminar de executar a primeira função, o endereço de memória do terceiro item é aonde o processador
vai retornar quando terminar a segunda função, e assim por diante.</p></blockquote><p>Em amarelo estão os nomes das funções, em verde os arquivos de código-fonte em que elas se encontram</p><p>Claro que a do GDB está mais bonita do que vamos gerar inicialmente, mas existe um jeito de você
mostrar exatamente os nomes de cada função. Pretendo falar disso na parte 2.</p><p>Existem três jeitos de você carregar um &ldquo;crash handler&rdquo;:</p><ol><li>como um serviço (ou daemon) rodando na máquina. O Google Chrome faz assim.<br>A Microsoft faz também (aquela janela que pede pra você enviar o relatório de erros pra
Microsoft é uma espécie de <strong>crash handler</strong>)</li><li>como um launcher para o seu aplicativo ou jogo. O Minecraft faz desse jeito</li><li>fazer o próprio aplicativo carregar o handler (no início, ou, caso seja possível, quando o
programa crashar). A maioria dos programas e jogos fazem assim.</li></ol><p>O jeito que eu fiz foi o segundo jeito, como um launcher, porque eu achei mais fácil pra mim.<br>Eu pretendo testar o terceiro jeito, porque eu acho que é o mais fácil para o usuário (ele não
precisa carregar um programa externo pra carregar o programa que ele quer).</p><p>O <em>crash handler</em> tem sua ação dividida em duas partes: a parte do software que crashou e a parte
do handler. O handler não faz nada até o programa monitorado crashar.</p><h3 id=no-início>No início<a href=#no-início class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Alguns sistemas, dentre eles o Linux, lhe permitem executar funções em determinados eventos, chamados
de <strong>sinais</strong>. Essas funções são chamadas de <em>signal handlers</em> Para alterar essas funções, você
deve usar uma função chamada <a href=https://www.man7.org/linux/man-pages/man2/sigaction.2.html>sigaction</a>.</p><blockquote><p>No Windows, o método é diferente. Veremos isso futuramente também.</p></blockquote><p>Alguns desses sinais são executados quando o programa faz algo que não deveria. São eles os que
queremos.</p><blockquote><p>A função que passarmos precisa ser uma função normal. Ela <em>não pode</em> estar dentro de nenhuma
instância, nem ser um <code>lambda</code> de C++, nem nada retornado pelo <code>std::bind</code>, por uma questão de
lifetimes, e porque você não deve confiar em nenhum trecho da memória que o seu aplicativo
estava usando, afinal ele crashou!</p></blockquote><p>O protótipo dessa função é:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sigaction</span>(<span style=color:#66d9ef>int</span> signum, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sigaction <span style=color:#f92672>*</span>act, <span style=color:#66d9ef>struct</span> sigaction <span style=color:#f92672>*</span>oldact);
</span></span></code></pre></div><ul><li>signum é o número do sinal (embora geralmente você use um <code>#define</code> que já liga o nome ao número).<br>Uma lista de sinais está <a href=https://www.man7.org/linux/man-pages/man7/signal.7.html>disponível aqui</a>,
na seção &ldquo;Standard signals&rdquo;.</li><li><code>sigaction</code> é uma estrutura que contém alguns valores, um deles é o ponteiro pra nossa função,
que será executada durante o sinal que queremos</li><li><code>act</code> e <code>oldact</code> são ponteiros para a estrutura acima: no primeiro você passa o valor que você
quer setar, no segundo você passa um ponteiro de memória onde essa função vai escrever o valor antigo.</li></ul><p>Você deve criar handlers para alguns sinais fatais, mas que podem ser capturados (<code>SIGSTOP</code> e
<code>SIGKILL</code> não podem, afinal, geralmente, eles são causados pelo usuário).</p><p>Os que eu escolhi para esse tutorial foram <code>SIGSEGV</code> (o famoso Segmentation fault), <code>SIGABRT</code>
(um &ldquo;crash voluntário&rdquo;, geralmente causado por exceções não tratadas em C++) e <code>SIGBUS</code>
(um sinal causado para erros de acesso a memória que não são falhas de segmentação), porque eles
são os mais comuns.</p><p>Você pode (e deve) pegar todos os sinais fatais, eu só não vou pegar todos pro código ficar um
pouco menor.</p><blockquote><p>Os sinais fatais são aqueles que, naquela lista de sinais, tem a <strong>Action</strong> igual a <strong>Core</strong>.
Eles geralmente resultam no fim da execução do programa</p></blockquote><p>Existem dois jeitos de iniciar:</p><ul><li>o handler inicia o programa e pega o Process ID (ou ID do Processo)</li><li>o programa inicia, executa o handler e passa o próprio Process ID pra ele.</li></ul><p>Nos dois casos, o handler precisa do process ID do programa que você quer monitorar.</p><p>Agora, o que o programa a ser crashado faz é, assim que ele é iniciado, configurar esses <em>handlers</em>
para uma função que será executada na hora do crash.</p><p>O handler espera o processo terminar. <a href=https://linux.die.net/man/2/waitpid>A função <code>waitpid</code></a> lhe
permite fazer isso. Você passa pra ela o process ID e um ponteiro de memória pra guardar as informações
de retorno da função e ela só retorna quando o processo cujo PID você passou terminar.</p><h2 id=na-hora-do-crash>Na hora do crash<a href=#na-hora-do-crash class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Na hora do crash, a função que passamos é executada</p><p>A assinatura da nossa função precisa ser essa daqui:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handler</span>(<span style=color:#66d9ef>int</span> signum, siginfo_t<span style=color:#f92672>*</span> siginfo, <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> context) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>signum</code> é o número do sinal</li><li><code>siginfo</code> é uma estrutura que contém informações sobre o sinal, como o que exatamente o causou.
Por algum motivo que eu não sei, o valor do <code>instruction pointer</code> (ou o endereço da instrução
que o processo estava quando o sinal aconteceu) não está aí, e isso me deixou um pouco puto.</li><li><code>context</code> é o endereço pra uma estrutura onde os valores mais interessantes são dependentes
da arquitetura</li></ul><blockquote><p>Esse guia só funciona pra x86-64. Como eu tenho um Raspberry PI, eu prometo que vou fazer um
post só com os específicos para ARM no Linux.</p></blockquote><h1 id=todo>TODO<a href=#todo class=hanchor arialabel=Anchor>&#8983;</a></h1><ul><li>falar do context, e de como pegar os valores dos registradores</li><li>falar como pega a call stack</li><li>falar como manda a call stack pro processo do crash handler</li></ul></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-arthurmco-github-io-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__dates><h4>Archive</h4><ul id=date-archive><li><a href=https://arthurmco.github.io/blog/archive/202208>August 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202207>July 2022</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202205>May 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202204>April 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202203>March 2022</a> (2)</li></optgroup><li><a href=https://arthurmco.github.io/blog/archive/202109>September 2021</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202104>April 2021</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202102>February 2021</a> (3)</li></optgroup></li></div><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://arthurmco.github.io/blog/assets/main.js></script>
<script src=https://arthurmco.github.io/blog/assets/prism.js></script></div></body></html>