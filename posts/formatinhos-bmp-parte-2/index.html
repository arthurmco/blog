<!doctype html><html lang=en><head><title>Formatinhos: BMP - Parte 2: Outras profundidades de cor :: Blog do Arthur M.</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="O segundo episódio da série de um dos formatos de imagens historicamente mais fáceis
de parsear.

Nesse post você vai conseguir ler todas as profundidades de cor, pelo menos do bitmap RGB.
"><meta name=keywords content="formatinhos,bmp,imagem,bitmap,microsoft"><meta name=robots content="noodp"><link rel=canonical href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/style.css><link rel=stylesheet href=https://arthurmco.github.io/blog/assets/red.css><link rel=apple-touch-icon href=https://arthurmco.github.io/blog/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://arthurmco.github.io/blog/img/favicon/red.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Formatinhos: BMP - Parte 2: Outras profundidades de cor"><meta property="og:description" content="O segundo episódio da série de um dos formatos de imagens historicamente mais fáceis
de parsear.

Nesse post você vai conseguir ler todas as profundidades de cor, pelo menos do bitmap RGB.
"><meta property="og:url" content="https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/"><meta property="og:site_name" content="Blog do Arthur M."><meta property="og:image" content="https://arthurmco.github.io/blog/img/favicon/red.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-08-14 14:40:54 -0300 -0300"></head><body class=red><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://arthurmco.github.io/blog/><div class=logo>Blog do Arthur M.</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/>Formatinhos: BMP - Parte 2: Outras profundidades de cor</a></h1><div class=post-meta><span class=post-date>2022-08-14
[Modificado em: 2022-08-14]</span>
<span class=post-author>:: Arthur Mendes</span>
<span class=post-reading-time><br>4
minutos
estimados de leitura</span></div><span class=post-tags>#<a href=https://arthurmco.github.io/blog/tags/code/>code</a>&nbsp;
#<a href=https://arthurmco.github.io/blog/tags/formats/>formats</a>&nbsp;</span><div class=post-content><div><p>Na <a href=https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-1/>primeira parte</a>, aprendemos o básico sobre como
ler um arquivo de bitmap.</p><p>Mas nós lemos apenas uma profundidade de cor</p><p>Nesse post, aprenderemos a ler as outras profundidades</p><p>O arquivo bitmap suporta 6 profundidades de cor: 32bpp, 24bpp, 16bpp, 8bpp, 4bpp, e 1bpp.</p><p>Elas são divididas em três grupos:</p><ul><li>16 bpp e maiores têm as informações de cor escritas diretamente no array de pixels.</li><li>8 bpp e menores têm, no lugar das cores, um índice para uma paleta de cores, que fica entre
o header DIB e o array de pixels.</li></ul><p>As três primeiras são <em>bem fáceis</em></p><div class=collapsable-code><input id=674298153 type=checkbox>
<label for=674298153><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>bmp.js: Parsing dos pixels por profundidade de cor</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
function getColors32(y, x, buffer, pixelpos) {
    // format RGBA
    return [
        get8(buffer, pixelpos(y, x) &#43; 2),
        get8(buffer, pixelpos(y, x) &#43; 1),
        get8(buffer, pixelpos(y, x) &#43; 0),
        0xff
    ];
}

 function getColors24(y, x, buffer, pixelpos) {
    // format RGBA
    return [
        get8(buffer, pixelpos(y, x) &#43; 2),
        get8(buffer, pixelpos(y, x) &#43; 1),
        get8(buffer, pixelpos(y, x) &#43; 0),
        0xff
    ];
}

function getColors16(y, x, buffer, pixelpos) {
    const value = get16(buffer, pixelpos(y, x));

    const cast16to24 = (v) =&gt; Math.floor(v / 32 * 255);

    const b = cast16to24((value &gt;&gt;&gt; 0) &amp; 0x1f);
    const g = cast16to24((value &gt;&gt;&gt; 5) &amp; 0x1f);
    const r = cast16to24((value &gt;&gt;&gt; 10) &amp; 0x1f);

    return [r, g, b, 0xff];
}

</code></pre></div><blockquote><p>(Juntar essas funções no código anterior fica como um exercício para o leitor. Mas <em>não é difícil</em>.
É só prestar atenção no conteúdo das funções.)</p></blockquote><p>A mais complicada é 16bpp, já que, nela, cada canal de cor tem menos do que um byte.</p><p>Antes de falar dos canais com profundidade de cor menor, eu preciso falar da <strong>paleta</strong></p><h1 id=paleta>Paleta<a href=#paleta class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Obrigatoriamente, se a profundidade de cor de sua imagem for menor ou igual a 8 bits por pixel, a
paleta será sempre definida.</p><p>O tamanho da paleta é definida pelo campo <code>blClrUsed</code> (definida no código como <code>paletteColors</code>).<br>Se ele for 0, e a imagem tiver 8 bits por pixel ou menor, é a quantidade máxima permitida (2
elevado a quantidade de bits por pixel).<br>Se ele for maior que 0, a quantidade de cores ali vai ser o tamanho da paleta.</p><p>Logo depois do header (ou seja, você vai até o começo do header e soma <code>biSize</code>), teremos um array
de pixels em formato BGRX.<br>Isso significa que primeiro vem o azul, depois verde, depois vermelho e depois um byte de <em>padding</em>,
que <strong>não é o canal alfa</strong>.</p><p>Pra quem parseou um header, ler essas cores é muito simples. É a mesma coisa que ler o array de
pixels, na verdade.</p><div class=collapsable-code><input id=139826745 type=checkbox>
<label for=139826745><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>bmp.js: Parsing da paleta de cores</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
function getColorTable(header, buffer) {
    if (header.dibHeader.bpp &gt; 8)
        return null;

    const colorTableOffset = header.fileHeaderSize &#43; header.dibHeader.size;
    const tableSize = (header.dibHeader.paletteColors === 0 ) ? 
        2 ** header.dibHeader.bpp :
        header.dibHeader.paletteColors;

    let table = [];

    const getColor = (i) =&gt; {
        const off = colorTableOffset &#43; (i * 4);
        return {
            b: get8(buffer, off),
            g: get8(buffer, off &#43; 1),
            r: get8(buffer, off &#43; 2),
            a: get8(buffer, off &#43; 3)
        };

    }

    for (let i = 0; i &lt; tableSize; i&#43;&#43;) {
        table.push(getColor(i));
    }

    return table;
}
</code></pre></div><h1 id=as-profundidades-de-cor-finais>As profundidades de cor finais<a href=#as-profundidades-de-cor-finais class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Agora que você tem a tabela de cores, ler os outros formatos fica muito mais fácil.</p><div class=collapsable-code><input id=187265943 type=checkbox>
<label for=187265943><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>bmp.js: Parsing dos pixels por profundidade de cor II</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
function getColors8(y, x, buffer, pixelpos, table) {
    const { r, g, b } = table[get8(buffer, pixelpos(y, x))];
    return [r, g, b, 0xff];
}


function getColors4(y, x, buffer, pixelpos, table) {
    const byte = get8(buffer, pixelpos(y, x));
    const value = (x % 2 == 0) ? (byte &gt;&gt; 4) : (byte &amp; 0xf);

    const { r, g, b } = table[value];
    return [r, g, b, 0xff];
}

function getColors1(y, x, buffer, pixelpos, table) {
    const byte = get8(buffer, pixelpos(y, x));
    const bit = x % 8;

    const value = (byte &gt;&gt; (7-bit)) &amp; 1;

    const { r, g, b } = table[value];
    return [r, g, b, 0xff];
}
</code></pre></div><p>Novamente, juntar essas funções vai ficar a cargo do leitor :)</p><hr><p>Agora, qualquer bitmap que o Paint gerar você consegue abrir. Mas e quanto os outros programas?</p><p>Você deve ter reparado que, por exemplo, alguns bitmaps salvos pelo Gimp não conseguem ser abertos
corretamente. Isso porque eles usam um método de &ldquo;compressão&rdquo; (que não é compressão, é só a
definição do formato) chamado <code>BITFIELDS</code>. Esse método nos permite especificar exatamente quanto de
verde, vermelho e azul a imagem vai ter,</p><p>Na próxima parte, iremos ler as informações de bitfields do arquivo de bitmap.</p><h1 id=referências>Referências<a href=#referências class=hanchor arialabel=Anchor>&#8983;</a></h1><ul><li><a href=https://docs.microsoft.com/pt-br/windows/win32/gdi/bitmap-storage>https://docs.microsoft.com/pt-br/windows/win32/gdi/bitmap-storage</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc7903#section-1.2>https://datatracker.ietf.org/doc/html/rfc7903#section-1.2</a></li></ul></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-arthurmco-github-io-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__dates><h4>Archive</h4><ul id=date-archive><li><a href=https://arthurmco.github.io/blog/archive/202208>August 2022</a> (6)</li><li><a href=https://arthurmco.github.io/blog/archive/202207>July 2022</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202205>May 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202204>April 2022</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202203>March 2022</a> (2)</li></optgroup><li><a href=https://arthurmco.github.io/blog/archive/202109>September 2021</a> (2)</li><li><a href=https://arthurmco.github.io/blog/archive/202104>April 2021</a> (1)</li><li><a href=https://arthurmco.github.io/blog/archive/202102>February 2021</a> (3)</li></optgroup></li></div><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a> :: forked by <a href=https://twitter.com/usrbinarthur>arthurmco</a></span></div></div></footer><script src=https://arthurmco.github.io/blog/assets/main.js></script>
<script src=https://arthurmco.github.io/blog/assets/prism.js></script></div></body></html>