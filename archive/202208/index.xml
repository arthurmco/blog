<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2022@08 on Blog do Arthur M.</title><link>https://arthurmco.github.io/blog/archive/202208/</link><description>Recent content in 2022@08 on Blog do Arthur M.</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Thu, 11 Aug 2022 14:25:28 -0300</lastBuildDate><atom:link href="https://arthurmco.github.io/blog/archive/202208/index.xml" rel="self" type="application/rss+xml"/><item><title>Formatinhos: Prelúdio</title><link>https://arthurmco.github.io/blog/posts/meta-glossario-formatinhos/</link><pubDate>Thu, 11 Aug 2022 14:25:28 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/meta-glossario-formatinhos/</guid><description>&lt;p>Amanhã é o lançamento da minha série dos formatinhos, com o primeiro episódio sendo o dos
arquivos &lt;strong>.bmp&lt;/strong>&lt;/p>
&lt;p>Os posts da série terão descrições padronizadas de algumas estruturas de dados. Alguns de vocês
podem estar familiarizados com esse tipo de descrição, mas, como eu tento escrever para os
júniores e as sandys, eu vou explicar.&lt;/p>
&lt;p>Se você começar a ler esse post e se pegar pensando &amp;ldquo;Eu já sei isso&amp;rdquo;, então você já pode começar
a ver a série dos formatinhos.&lt;/p></description><content>&lt;p>Amanhã é o lançamento da minha série dos formatinhos, com o primeiro episódio sendo o dos
arquivos &lt;strong>.bmp&lt;/strong>&lt;/p>
&lt;p>Os posts da série terão descrições padronizadas de algumas estruturas de dados. Alguns de vocês
podem estar familiarizados com esse tipo de descrição, mas, como eu tento escrever para os
júniores e as sandys, eu vou explicar.&lt;/p>
&lt;p>Se você começar a ler esse post e se pegar pensando &amp;ldquo;Eu já sei isso&amp;rdquo;, então você já pode começar
a ver a série dos formatinhos.&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>Antes de mais nada, leia isso:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Numeração hexadecimal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pt.wikipedia.org/wiki/Extremidade_(ordena%C3%A7%C3%A3o)">Extremidade (ou &lt;em>endianness&lt;/em>)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Vai ser importante lá na frente!&lt;/p>
&lt;/blockquote>
&lt;p>O código será mostrado assim (aprendi a formatar o código desse jeito nessa semana, e fica bem
mais bonito, dá pra expandir e fica melhor em mobile.)&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="941853267" type="checkbox" />
&lt;label for="941853267">
&lt;span class="collapsable-code__language">c&amp;#43;&amp;#43;&lt;/span>
&lt;span class="collapsable-code__title">Código exemplo&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-c&amp;#43;&amp;#43;" >&lt;code>
#include &amp;lt;cstdint&amp;gt;
#include &amp;lt;string&amp;gt;
struct Teste {
int8_t val1;
int8_t val2;
std::string str;
}
int testa_o_teste(const Teste&amp;amp; teste, int valor) {
// aaaaaaa
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Eu vou tentar ser o mais didático possível no código. Se algo não ficar claro, você pode comentar.&lt;/p>
&lt;p>Em algumas partes do post, eu vou precisar mostrar dumps hexadecimais e estruturas de dados,
geralmente juntos.&lt;/p>
&lt;p>Um dump hexadecimal é algo parecido com isso:&lt;br>
(Ele quebra em mobile :(. Até eu resolver isso, veja esse dump com o celular na horizontal)&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 45 58 45 4d 00 04 00 00 00 04 00 00 20 03 8f 3d |EXEM........ ..=|
00000010 18 00 00 00 20 03 00 00 41 69 20 71 75 65 20 73 |.... ...Ai que s|
00000020 61 63 6f 00 |aco.|
00000024
&lt;/code>&lt;/pre>&lt;p>O dump acima está em um formato padrão (de um programa chamado &lt;code>hexdump&lt;/code>). Todos os valores
das três primeiras colunas estão em hexadecimal.&lt;/p>
&lt;p>A primeira coluna mostra um valor que representa a posição do byte logo depois dela,
em hexadecimal. (&lt;code>00000010&lt;/code> = 16 em decimal, &lt;code>00000020&lt;/code> = 32 em decimal, &lt;code>00000024&lt;/code> = 36).&lt;/p>
&lt;p>A segunda coluna mostra os bytes 0 até 7 da linha. Ou seja:&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 45 58 45 4d 00 04 00 00
&lt;/code>&lt;/pre>&lt;p>O primeiro byte é &lt;code>45&lt;/code>, o segundo é &lt;code>58&lt;/code>, o terceiro é &lt;code>45&lt;/code> denovo&amp;hellip;&lt;/p>
&lt;pre tabindex="0">&lt;code>00000010 18 00 00 00 20 03 00 00
&lt;/code>&lt;/pre>&lt;p>O décimo sexto byte é &lt;code>18&lt;/code>, do 17 ao 19 são &lt;code>00&lt;/code>, o vigésimo byte, por coincidéncia, é &lt;code>20&lt;/code>&amp;hellip;&lt;/p>
&lt;p>E por aí vai&lt;/p>
&lt;p>A terceira coluna mostra os bytes 8 até 15. Mesmo esquema.&lt;/p>
&lt;p>A quarta coluna é a representação, em ASCII, dos bytes daquela linha:&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 45 58 45 4d 00 04 00 00 00 04 00 00 20 03 8f 3d |EXEM........ ..=|
&lt;/code>&lt;/pre>&lt;p>&amp;lsquo;E&amp;rsquo; = &lt;code>45&lt;/code>, &amp;lsquo;X&amp;rsquo; = &lt;code>58&lt;/code>, &amp;lsquo;M&amp;rsquo; = &lt;code>4d&lt;/code>&amp;hellip; você entendeu. Os valores que não têm um caractere
correspondente printável são representados com um ponto.&lt;/p>
&lt;p>Geralmente, o dump vai vir acompanhado de uma tabela mostrando o que tem dentro do arquivo.&lt;br>
Cada linha da tabela é um &lt;strong>campo&lt;/strong>, um valor que significa alguma coisa.&lt;br>
Por exemplo:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Posição&lt;/th>
&lt;th>Tamanho&lt;/th>
&lt;th>Campo&lt;/th>
&lt;th>Valor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>0x0 (0) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>MAGIC&lt;/td>
&lt;td>&lt;code>45 58 45 4d&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x4 (4) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>width&lt;/td>
&lt;td>&lt;code>0x400&lt;/code> = 1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x8 (8) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>height&lt;/td>
&lt;td>&lt;code>0x400&lt;/code> = 1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xC (12) &lt;/code>&lt;/td>
&lt;td>1&lt;/td>
&lt;td>bit depth&lt;/td>
&lt;td>&lt;code>0x20&lt;/code> = 32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xD (13) &lt;/code>&lt;/td>
&lt;td>1&lt;/td>
&lt;td>compression&lt;/td>
&lt;td>&lt;code>0x3&lt;/code> = RLE8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xE (14) &lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>checksum&lt;/td>
&lt;td>&lt;code>8f 3d&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x10 (16) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>name offset&lt;/td>
&lt;td>&lt;code>0x18&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x14 (20) &lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>data offset&lt;/td>
&lt;td>&lt;code>0x320&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Na coluna &lt;strong>Posição&lt;/strong> eu mostro em qual posição (tanto em decimal quanto em hexadecimal) o campo
fica dentro do arquivo. A posição sempre vai ser em bytes.&lt;/p>
&lt;p>O &lt;strong>Tamanho&lt;/strong> é o tamanho, em bytes, daquele campo.&lt;/p>
&lt;p>O &lt;strong>campo&lt;/strong> é o nome do campo, como ele está na documentação. Se a documentação for informal, vai
ser um nome que eu vou inventar e que descreve o campo.&lt;/p>
&lt;p>O &lt;strong>valor&lt;/strong> é o valor atual do campo, pra você não precisar gastar neurônios caçando a posição
exata do campo. Os valores que significam números estão convertidos, e os zeros extras são
removidos.&lt;/p>
&lt;p>Eu geralmente vou mostrar campos com tamanho variável separadamente. Por exemplo:&lt;/p>
&lt;ul>
&lt;li>O campo &lt;code>name offset&lt;/code> aponta para uma &lt;em>string&lt;/em> terminada em &lt;code>NUL&lt;/code> (&lt;code>&amp;quot;Ai que saco&amp;quot;&lt;/code>).&lt;/li>
&lt;/ul>
&lt;p>Uma string terminada em &lt;code>NUL&lt;/code> é uma string que termina em um byte &lt;code>0&lt;/code>. É a string que o C usa.&lt;/p>
&lt;hr>
&lt;p>E é isso.&lt;/p>
&lt;p>Se você sentiu que eu não expliquei algo direito, comente aí que eu altero a postagem explicando
melhor.&lt;/p>
&lt;p>Amanhã a gente começa!&lt;/p></content></item><item><title>Nova série de posts: Formatinhos</title><link>https://arthurmco.github.io/blog/posts/nova-serie-formatinhos/</link><pubDate>Thu, 04 Aug 2022 20:57:41 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/nova-serie-formatinhos/</guid><description>&lt;p>Nesse mês, eu comecei a pensar em alguns jeitos de movimentar esse blog um pouco mais.&lt;/p>
&lt;p>Um desses jeitos foi criar uma espécie de &amp;ldquo;série&amp;rdquo; de postagens, várias postagens sobre um mesmo
tema, que ensinassem algo interessante de aprender.&lt;/p>
&lt;p>Depois de pensar bastante, cheguei numa ideia.&lt;/p>
&lt;p>A série &lt;strong>Formatinhos&lt;/strong>.&lt;/p>
&lt;p>Uma vez por semana, eu vou trazer aqui um formato de arquivo diferente. Irei ensinar o que significa
cada coisa dentro do formato enquanto nós fazemos um &lt;em>parser&lt;/em> para ele e o mostramos.&lt;br>
Como ele vai ser mostrado depende do arquivo.&lt;/p></description><content>&lt;p>Nesse mês, eu comecei a pensar em alguns jeitos de movimentar esse blog um pouco mais.&lt;/p>
&lt;p>Um desses jeitos foi criar uma espécie de &amp;ldquo;série&amp;rdquo; de postagens, várias postagens sobre um mesmo
tema, que ensinassem algo interessante de aprender.&lt;/p>
&lt;p>Depois de pensar bastante, cheguei numa ideia.&lt;/p>
&lt;p>A série &lt;strong>Formatinhos&lt;/strong>.&lt;/p>
&lt;p>Uma vez por semana, eu vou trazer aqui um formato de arquivo diferente. Irei ensinar o que significa
cada coisa dentro do formato enquanto nós fazemos um &lt;em>parser&lt;/em> para ele e o mostramos.&lt;br>
Como ele vai ser mostrado depende do arquivo.&lt;/p>
&lt;p>Alguns formatos que eu já estou pensando em falar aqui (sem uma ordem específica):&lt;/p>
&lt;ul>
&lt;li>ZIP&lt;/li>
&lt;li>TAR.GZ (são 2 formatos diferentes mas é um arquivo só)&lt;/li>
&lt;li>ISO&lt;/li>
&lt;li>BMP&lt;/li>
&lt;li>WAV (PCM, A-Law, µ-Law, ADPCM)&lt;/li>
&lt;li>o sistema de arquivos FAT (12, 16 e 32)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>Além disso, você também pode sugerir novos formatos, embora existam algumas regras:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Nada que dependa apenas de libs&lt;/strong>: sim, eu sei que eu posso usar alguma biblioteca pra abrir. Mas qual
é a graça?&lt;br>
As unicas libs que serão permitidas serão bibliotecas de compressão (zlib, gzip&amp;hellip;) ou criptografia
(openssl, libressl&amp;hellip;), porque:&lt;/p>
&lt;ol>
&lt;li>implementar essas duas coisas na mão é só pra quem tem muito tempo livre ou muita vontade.&lt;/li>
&lt;li>não é o foco do formato, o foco do formato são as estruturas de dados dentro dele.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Se pelo menos uma pessoa usar, tá válido&lt;/strong>: e essa pessoa inclui você!&lt;br>
Se você criou um formato e quer que ele apareça aqui, você pode sugerir.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tamanho não importa, mas tenha noção&lt;/strong>: Se ficar muito grande, eu posso dividir em várias
partes, mas tenha noção de que eu quero pelo menos poder mostrar algo na parte 1, nem que só seja
um &amp;ldquo;Hello World&amp;rdquo;, um pixel ou um simples segundo de áudio.&lt;br>
Se precisar de dez mil páginas só pra mostrar um &amp;ldquo;OI&amp;rdquo; na tela, aí vai ser f#da.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Complexidade não importa, mas tenha noção&lt;/strong>: Formatos complexos que exigem um conhecimento
matemático decente, como JPEG e MP3, podem ser sugeridos, mas eles vão ficar num limbo até eu
entender, porque a minha faculdade não me deu esses conhecimentos.&lt;br>
E eu aposto que várias pessoas tiveram uma faculdade ruim. Alguns &lt;em>devs&lt;/em> nem fizeram faculdade
ou têm uma base matemática decente. Isso significa que eu precisaria explicar tudo ou linkar
para um site que explique certos conceitos como transformada de Fourier de uma forma facilitada.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>E é isso.&lt;/p>
&lt;p>O primeiro post sai na próxima sexta, à noite.&lt;/p></content></item><item><title>Meu disquete não tá lendo!</title><link>https://arthurmco.github.io/blog/posts/meu-disquete-nao-ta-lendo-no-linux/</link><pubDate>Thu, 04 Aug 2022 20:07:38 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/meu-disquete-nao-ta-lendo-no-linux/</guid><description>Há alguns dias atrás, eu consegui um teclado de música usado, um Yamaha PSR-350 pra aprender a tocar música, já que era algo que eu sempre quis aprender. O que faltava, na real, era dinheiro pra comprar algum instrumento.
Não é um teclado muito novo, mas também não é muito antigo: é de algum lugar dos anos 2000.
O teclado aí. Fonte: fr.audiofanzine.com Uma das coisas que me chamou a atenção foi o fato de ele ter um belo leitor de disquetes, pra você poder salvar suas músicas pra tocar no PC, ou pra transmitir músicas pra tocá-las no teclado.</description><content>&lt;p>Há alguns dias atrás, eu consegui um teclado de música usado, um Yamaha PSR-350 pra aprender a
tocar música, já que era algo que eu sempre quis aprender. O que faltava, na real, era dinheiro pra
comprar algum instrumento.&lt;/p>
&lt;p>Não é um teclado muito novo, mas também não é muito antigo: é de algum lugar dos anos 2000.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://arthurmco.github.io/blog/blog/images/key/yamaha-psr-350.jpg" />
&lt;figcaption class="center" >O teclado aí. Fonte: fr.audiofanzine.com&lt;/figcaption>
&lt;/figure>
&lt;p>Uma das coisas que me chamou a atenção foi o fato de ele ter um belo leitor de disquetes, pra você
poder salvar suas músicas pra tocar no PC, ou pra transmitir músicas pra tocá-las no teclado.&lt;/p>
&lt;p>Depois de algumas semanas esperando meu leitor de disquete USB chegar da China, eu pude testá-lo com
alguns disquetes que eu tinha comprado.&lt;/p>
&lt;p>Infelizmente, para minha surpresa, o disco mostrou uma mensagem nada amigável.&lt;/p>
&lt;pre tabindex="0">&lt;code>[ 1780.060701] sd 7:0:0:0: [sdc] Attached SCSI removable disk
[ 1827.483175] sd 7:0:0:0: [sdc] Read Capacity(10) failed: Result: hostbyte=DID_OK driverbyte=DRIVER_SENSE
[ 1827.483178] sd 7:0:0:0: [sdc] Sense Key : Medium Error [current]
[ 1827.483179] sd 7:0:0:0: [sdc] Add. Sense: Cannot read medium - unknown format
&lt;/code>&lt;/pre>&lt;p>Claro que eu pensei que o leitor estava quebrado.&lt;/p>
&lt;p>Porém, como ele estaria quebrado se ele foi reconhecido? Provavelmente era algum problema com o
disquete que eu usei.&lt;/p>
&lt;p>Então eu tentei outro, novinho em folha. Mesmo erro.&lt;/p>
&lt;hr>
&lt;p>Irei poupar a vocês as horas de pesquisa vendo fóruns e mais fóruns, e lhes mostrar direto o que
eu fiz pra resolver:&lt;/p>
&lt;p>O problema era que o disquete não estava formatado em &lt;strong>baixo nível&lt;/strong>.&lt;/p>
&lt;p>Você deve ter reparado, caso você tenha uns 30 e poucos anos no mínimo, que um disquete de 720KB ou
1.44MB podia ser usado em várias arquiteturas de computador diferente, mas eles eram incompatíveis
entre si: um disquete no PC não funcionava no Apple II e vice-versa.&lt;/p>
&lt;p>Isso se devia ao fato que esses sistemas esperavam que &lt;em>os setores estivessem em lugares diferentes
do disco&lt;/em>.&lt;/p>
&lt;p>O disquete é uma mídia dividida em &lt;em>cabeças&lt;/em>, &lt;em>trilhas&lt;/em> e &lt;em>setores&lt;/em> (heads, tracks e
sectors). Um disquete de 1.44 MB contém 2 cabeças, 80 trilhas e 18 setores por trilha,
cada setor tendo 512 bytes.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://arthurmco.github.io/blog/blog/images/key/heads.jpg" />
&lt;figcaption class="center" >Como o disquete é organizado fisicamente. Fonte: researchgate.net&lt;/figcaption>
&lt;/figure>
&lt;p>A quantidade de cabeças é pré-definida, mas, em alguns discos, as trilhas e os setores, não são. Eles
são definidos por software, em padrões de bits gravados no disquete que informam onde a trilha começa e
o tamanho de cada setor. Essa definição é chamada de &lt;em>formatação de baixo-nível&lt;/em>, ou &lt;em>low-level formatting&lt;/em>&lt;/p>
&lt;p>O problema é que os disquetes que eu comprei não tinham esses padrões de bits, eles não estavam
&amp;ldquo;formatados&amp;rdquo;.&lt;/p>
&lt;h2 id="solucionando">Solucionando&lt;/h2>
&lt;p>Para você fazer isso no Linux, você deve baixar um utilitário chamado ufiformat.
&lt;a href="https://github.com/tedigh/ufiformat">O link para o repositório&lt;/a>.&lt;/p>
&lt;p>Ele não está compilado, mas compilar é tranquilo: instale o pacote &lt;code>e2fs-progs&lt;/code> para compilar
(deve ser algo chamado &lt;code>e2fsprogs-dev&lt;/code> no Debian e derivados), depois é só dar &lt;code>./configure&lt;/code> e
&lt;code>make&lt;/code>.&lt;/p>
&lt;p>Para listar os dispositivos disponíveis, digite &lt;code>./ufiformat -i&lt;/code>.&lt;/p>
&lt;p>Para rodar, digite &lt;code>./ufiformat -V -v /dev/&amp;lt;teu disquete&amp;gt;&lt;/code>. Ele vai rodar e depois verificar para
ver se deu certo.&lt;br>
Depois que ele terminar, tire o disquete e coloque denovo.&lt;br>
Se isso daqui aparecer no &lt;code>dmesg&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[ 2213.047066] usb 3-4: reset full-speed USB device number 8 using xhci_hcd
[ 2213.273042] sd 7:0:0:0: Power-on or device reset occurred
[ 2214.872958] sd 7:0:0:0: [sdc] 2880 512-byte logical blocks: (1.47 MB/1.41 MiB)
[ 2321.016219] sdc:
&lt;/code>&lt;/pre>&lt;p>significa que deu certo.&lt;/p>
&lt;h1 id="e-no-windows">E no Windows?&lt;/h1>
&lt;p>No Windows é mais fácil que parece.&lt;/p>
&lt;p>Quando você inserir o disquete, ele vai dar uma mensagem de erro dizendo que o disco pode não estar
formatado.&lt;/p>
&lt;p>Você pode achar que ele está falando do sistema de arquivos, mas ele está falando mesmo da definição
de setores, do low level.&lt;/p>
&lt;p>Clique com o botão direito no disquete e vá em &amp;ldquo;Formatar&amp;rdquo;. Uma janela assim vai aparecer:&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/key/winformat.png" alt="A janela te pedindo pra formatar">&lt;/p>
&lt;p>Sabe essa opção &amp;ldquo;Formatação Rápida&amp;rdquo;? &lt;strong>Não marque ela.&lt;/strong> Se ela tiver selecionada, &lt;strong>desmarque&lt;/strong>.
Se você selecionar, ela não vai formatar o disquete em baixo nível.&lt;/p>
&lt;p>Clique em Iniciar e espere uns minutinhos.&lt;/p>
&lt;p>Depois disso, corre pro abraço!&lt;/p></content></item></channel></rss>