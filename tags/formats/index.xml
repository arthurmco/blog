<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>formats on Blog do Arthur M.</title><link>https://arthurmco.github.io/blog/tags/formats/</link><description>Recent content in formats on Blog do Arthur M.</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Fri, 19 Aug 2022 23:22:11 -0300</lastBuildDate><atom:link href="https://arthurmco.github.io/blog/tags/formats/index.xml" rel="self" type="application/rss+xml"/><item><title>Formatinhos: TAR.GZ</title><link>https://arthurmco.github.io/blog/posts/formatinhos-targz/</link><pubDate>Fri, 19 Aug 2022 23:22:11 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/formatinhos-targz/</guid><description>O tar é o formato mais tradicional de arquivamento do universo Unix, sendo usado desde o final da década de 70, muito antes do ZIP sequer ser pensado.
O tar é diferente de outros formatos de arquivamento porque ele não comprime arquivos individualmente. Todos o arquivo tar é comprimido junto. Para extrair os arquivos, você deve primeiro descomprimir o arquivo .tar inteiro.
Para identificar o formato de compressão, você adiciona um sufixo no arquivo.</description><content>&lt;p>O &lt;code>tar&lt;/code> é o formato mais tradicional de arquivamento do universo Unix, sendo usado desde o final da
década de 70, muito antes do ZIP sequer ser pensado.&lt;/p>
&lt;p>O &lt;code>tar&lt;/code> é diferente de outros formatos de arquivamento porque ele não comprime arquivos individualmente.
Todos o arquivo tar é comprimido junto. Para extrair os arquivos, você deve primeiro descomprimir o
arquivo &lt;code>.tar&lt;/code> inteiro.&lt;/p>
&lt;p>Para identificar o formato de compressão, você adiciona um sufixo no arquivo. Os formatos e sufixos
suportados são:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Sufixo&lt;/th>
&lt;th>Formato&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>‘.gz’&lt;/td>
&lt;td>gzip&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.tgz’&lt;/td>
&lt;td>gzip&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.taz’&lt;/td>
&lt;td>gzip&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.Z’&lt;/td>
&lt;td>compress&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.taZ’&lt;/td>
&lt;td>compress&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.bz2’&lt;/td>
&lt;td>bzip2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.tz2’&lt;/td>
&lt;td>bzip2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.tbz2’&lt;/td>
&lt;td>bzip2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.tbz’&lt;/td>
&lt;td>bzip2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.lz’&lt;/td>
&lt;td>lzip&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.lzma’&lt;/td>
&lt;td>lzma&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.tlz’&lt;/td>
&lt;td>lzma&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.lzo’&lt;/td>
&lt;td>lzop&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.xz’&lt;/td>
&lt;td>xz&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.zst’&lt;/td>
&lt;td>zstd&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>‘.tzst’&lt;/td>
&lt;td>zstd&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>O sufixo mais visto e o mais suportado é o .gz. Por isso que você vê muito &lt;code>.tar.gz&lt;/code>.&lt;/p>
&lt;h1 id="o-formato">O formato&lt;/h1>
&lt;p>O lado bom do arquivo .tar é que não existem valores binários: os valores binários dele estão nos
arquivos, não nos metadados.&lt;/p>
&lt;p>Todos os números são salvos em octal. Por exemplo, se você ver um &lt;code>10&lt;/code> no arquivo, significa que
o valor que está ali é 8, pois &lt;code>10&lt;/code> em octal é 8 em decimal. Assim como &lt;code>11&lt;/code>=9, &lt;code>12&lt;/code>=10, &lt;code>13&lt;/code>=11,
&lt;code>17&lt;/code>=15 e &lt;code>20&lt;/code>=16.&lt;/p>
&lt;p>As &lt;em>strings&lt;/em> têm um tamanho fixo. Se o tamanho delas no arquivo for menor que o tamanho fixo, vários
bytes &lt;code>0&lt;/code> são adicionados até chegarem nesse tamanho.&lt;/p>
&lt;p>O arquivo tar é dividido em blocos. Cada bloco possui 512 bytes. Esse também é o tamanho do header
contendo os metadados dos arquivos.&lt;/p>
&lt;p>O arquivo já começa com o header do primeiro arquivo:&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 67 72 61 70 68 69 63 61 6c 73 62 6f 75 6e 64 69 |graphicalsboundi|
00000010 6e 67 2e 72 73 00 00 00 00 00 00 00 00 00 00 00 |ng.rs...........|
00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
*
00000060 00 00 00 00 30 30 30 30 37 37 37 00 30 30 30 31 |....0000777.0001|
00000070 37 35 30 00 30 30 30 31 37 35 30 00 30 30 30 30 |750.0001750.0000|
00000080 30 30 30 37 36 30 33 00 31 34 32 37 33 30 30 32 |0007603.14273002|
00000090 32 37 35 00 30 31 35 37 37 34 00 20 30 00 00 00 |275.015774. 0...|
000000a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
*
00000100 00 75 73 74 61 72 20 20 00 61 72 74 68 75 72 6d |.ustar .arthurm|
00000110 63 6f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |co..............|
00000120 00 00 00 00 00 00 00 00 00 61 72 74 68 75 72 6d |.........arthurm|
00000130 63 6f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |co..............|
00000140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
*
000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Posição&lt;/th>
&lt;th>Tamanho&lt;/th>
&lt;th>Campo&lt;/th>
&lt;th>Valor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>0x0 (0)&lt;/code>&lt;/td>
&lt;td>100&lt;/td>
&lt;td>name&lt;/td>
&lt;td>&lt;code>graphicalsbounding.rs&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x64 (100)&lt;/code>&lt;/td>
&lt;td>8&lt;/td>
&lt;td>mode&lt;/td>
&lt;td>&lt;code>0000777&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x6c (108)&lt;/code>&lt;/td>
&lt;td>8&lt;/td>
&lt;td>uid&lt;/td>
&lt;td>&lt;code>0001750&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x74 (116)&lt;/code>&lt;/td>
&lt;td>8&lt;/td>
&lt;td>gid&lt;/td>
&lt;td>&lt;code>0001750&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x7c (124)&lt;/code>&lt;/td>
&lt;td>12&lt;/td>
&lt;td>size&lt;/td>
&lt;td>&lt;code>00000007603&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x88 (136)&lt;/code>&lt;/td>
&lt;td>12&lt;/td>
&lt;td>mtime&lt;/td>
&lt;td>&lt;code>14273002275&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x94 (148)&lt;/code>&lt;/td>
&lt;td>8&lt;/td>
&lt;td>chksum&lt;/td>
&lt;td>&lt;code>015774&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x9c (156)&lt;/code>&lt;/td>
&lt;td>1&lt;/td>
&lt;td>typeflag&lt;/td>
&lt;td>&lt;code>30&lt;/code> = &lt;code>REGTYPE&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x9d (157)&lt;/code>&lt;/td>
&lt;td>100&lt;/td>
&lt;td>linkname&lt;/td>
&lt;td>&lt;code> &lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x101 (257)&lt;/code>&lt;/td>
&lt;td>6&lt;/td>
&lt;td>magic&lt;/td>
&lt;td>&lt;code>ustar &lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x107 (263)&lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>version&lt;/td>
&lt;td>&lt;code>0x20 0x00&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x109 (265)&lt;/code>&lt;/td>
&lt;td>32&lt;/td>
&lt;td>uname&lt;/td>
&lt;td>&lt;code>arthurmco&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x129 (297)&lt;/code>&lt;/td>
&lt;td>32&lt;/td>
&lt;td>gname&lt;/td>
&lt;td>&lt;code>arthurmco&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x149 (329)&lt;/code>&lt;/td>
&lt;td>8&lt;/td>
&lt;td>devmajor&lt;/td>
&lt;td>&lt;code> &lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x151 (337)&lt;/code>&lt;/td>
&lt;td>8&lt;/td>
&lt;td>devminor&lt;/td>
&lt;td>&lt;code> &lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x159 (345)&lt;/code>&lt;/td>
&lt;td>155&lt;/td>
&lt;td>prefix&lt;/td>
&lt;td>&lt;code> &lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Como eu falei, &lt;strong>todos os números estão em formato octal&lt;/strong>.&lt;/p>
&lt;p>Depois desse header, no próximo bloco está o conteúdo do arquivo.&lt;/p>
&lt;p>Quando o arquivo termina, o header começa no próximo bloco, no próximo byte múltiplo de 512.&lt;/p>
&lt;p>Ou seja, se o arquivo acabar no byte 5090, o header só vai começar no byte 5120, já que é o próximo
múltiplo de 512.&lt;/p>
&lt;p>Para sinalizar o final do arquivo, dois blocos vazios (ou seja, cheios de bytes 0) são escritos.&lt;/p>
&lt;p>O arquivo &lt;code>tar&lt;/code> é identificado pelo valor no campo &lt;code>magic&lt;/code>, ou seja &lt;code>ustar&lt;/code>. Existem mais tipos de
arquivos tar, e eles serão discutidos nas próximas partes.&lt;/p>
&lt;p>O checksum (escrito no campo &lt;code>chksum&lt;/code>) é calculado somando todos os bytes do header. Os bytes que
estariam no checksum são substituídos, na função do cálculo, por espaços (&lt;code> &lt;/code>, byte 32). O resultado
é escrito no campo (no caso da escrita) ou comparado com o valor do campo (no caso da leitura)&lt;/p>
&lt;p>&lt;code>uname&lt;/code> e &lt;code>gname&lt;/code> são os nomes do usuário e do grupo que criaram o arquivo. &lt;code>uid&lt;/code> e &lt;code>gid&lt;/code> são os IDs
de usuário e grupo.&lt;/p>
&lt;p>&lt;code>mtime&lt;/code> é a data da última modificação do arquivo, ou de criação se o arquivo nunca foi alterado. O
valor é a quantidade de segundos desde 01/01/1970.&lt;/p>
&lt;p>&lt;code>name&lt;/code> é o nome do arquivo. Se ele é um link que aponta pra outro arquivo, o nome desse arquivo
vai estar em &lt;code>linkname&lt;/code>.&lt;/p>
&lt;p>&lt;code>devmajor&lt;/code> e &lt;code>devminor&lt;/code> só fazem sentido se o arquivo for um device, tipo aqueles arquivos que
estão dentro da pasta &lt;code>/dev&lt;/code> nos linuxes e unixes da vida.&lt;/p>
&lt;h2 id="códigos">Códigos&lt;/h2>
&lt;p>Inicialmente, definiremos os valores possíveis nos campos &lt;code>mode&lt;/code> e &lt;code>typeflag&lt;/code>:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="692187543" type="checkbox" />
&lt;label for="692187543">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">tarfile.py: Estruturas possíveis nos valores&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
from enum import Enum, IntFlag
# Isso são flags.
# Significa que mais de um valor pode ser possível aqui.
class FileMode(IntFlag):
# O modo do arquivo
# Quando você dá `ls -l` no terminal, tem um monte de rwxrwxrwx.
# Isso é codificado aqui.&amp;#39;
# O significado está claro se você manja um pouco de inglês.
# Se não, separa as duas palavras e joga no google tradutor que vai estar
# correto.
OtherExec = 1
OtherWrite = 2
OtherRead = 4
GroupExec = 8
GroupWrite = 16
GroupRead = 32
OwnerExec = 64
OwnerWrite = 128
OwnerRead = 256
SetGid = 1024
SetUid = 2048
class FileType(Enum):
## O tipo de arquivo
# Um arquivo comum
Regular = 0
# Um link pra outro arquivo
Link = 1
# Um link simbólico. Esse valor está depreciado e não é usado
Symlink = 2
# Se você sabe o que são essas duas coisas abaixo, então você sabe o que
# significa tudo aqui nesse enum, e não está nem lendo esses comentários.
CharacterDevice = 3
BlockDevice = 4
# Representa uma pasta. Uma coisa engraçada é que, dentro do arquivo tar,
# logo depois da pasta, vêm os arquivos que estão dentro dela.
# Isso pode ser útil pra você.
Directory = 5
# Se você sabe o que é isso daqui, então você nem precisa desses comentários
FIFOPipe = 6
# Campo reservado.
Reserved = 7
# Como converter do valor do arquivo pro valor do enum
# O `val` é o caractere que vem do arquivo.
@staticmethod
def from_value(val):
selections = {
&amp;#34;0&amp;#34;: FileType.Regular,
&amp;#34;\0&amp;#34;: FileType.Regular,
&amp;#34;1&amp;#34;: FileType.Link,
&amp;#34;2&amp;#34;: FileType.Symlink,
&amp;#34;3&amp;#34;: FileType.CharacterDevice,
&amp;#34;4&amp;#34;: FileType.BlockDevice,
&amp;#34;5&amp;#34;: FileType.Directory,
&amp;#34;6&amp;#34;: FileType.FIFOPipe,
&amp;#34;7&amp;#34;: FileType.Reserved
}
return selections.get(val, FileType.Reserved)
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Algumas funções auxiliares, que vão ajudar a ler o arquivo
&lt;div class="collapsable-code">
&lt;input id="784392156" type="checkbox" />
&lt;label for="784392156">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">tarfile.py: Funções auxiliares&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
# Isso aqui embaixo vem no final:
# Lê uma string do arquivo
def read_string(value):
return value.decode(&amp;#39;utf-8&amp;#39;).rstrip(&amp;#39;\x00 &amp;#39;)
# Lê um número do arquivo. Ele está em octal, então devemos converter.
def read_number(value, default=None):
try:
return int(read_string(value), base=8)
except ValueError:
return default
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>Depois, vamos ler o arquivo TAR:
&lt;div class="collapsable-code">
&lt;input id="439521768" type="checkbox" />
&lt;label for="439521768">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">tarfile.py: Estruturas do arquivo tar&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
## Coloque isso no começo do arquivo, antes do `from enum`
from dataclasses import dataclass
## Isso aqui embaixo vem no final:
# O tamanho do bloco:
BLOCK_SIZE = 512
@dataclass
class TarFile:
# Você já conhece esses campos :)
name: str
mode: FileMode
uid: int
gid: int
size: int
mtime: dt.datetime
checksum: int
typeflag: FileType
linkname: str
magic: str
version: int
uname: str
gname: str
devmajor: int
devminor: int
prefix: str
# O offset do arquivo que segue esse header, pra gente poder ler ele
# depois
offset: int
# O offset do próprio header.
header: int
def read_file(self, fileobject):
# Lê o conteúdo do arquivo que esse header representa
tell = fileobject.tell()
fileobject.seek(self.offset)
data = fileobject.read(self.size)
fileobject.seek(tell)
return data
def get_header_offset(self):
return self.offset - BLOCK_SIZE
def verify_checksum(self, fileobject):
# Verifica o checksum desse header, pra ver se ele é válido ou não.
tell = fileobject.tell()
fileobject.seek(self.get_header_offset())
data = fileobject.read(BLOCK_SIZE)
checksum = sum([v if i not in range(148, 156) else ord(&amp;#39; &amp;#39;)
for i, v in enumerate(data)])
fileobject.seek(tell)
return checksum == self.checksum
@staticmethod
def from_file(fileobject):
# Lê um arquivo.
#
# Esse `fileobject` é um objeto de arquivo, gerado pelo método `open`, ou
# por qualquer método que represente um arquivo, como `GzipFile` e outros
# similares.
#
# Esse método vai alterar o fileobject, fazendo ele apontar pro próximo
# bloco, que na maior parte das vezes vai ser o conteúdo do arquivo.
offset = fileobject.tell()
name = read_string(fileobject.read(100))
if name == &amp;#34;&amp;#34;:
return None
mode = FileMode(read_number(fileobject.read(8)))
uid = read_number(fileobject.read(8))
gid = read_number(fileobject.read(8))
size = read_number(fileobject.read(12))
mtime = dt.datetime.fromtimestamp(read_number(fileobject.read(12)))
checksum = read_number(fileobject.read(8))
typeflag = FileType.from_value(read_string(fileobject.read(1)))
linkname = read_string(fileobject.read(100))
magic = read_string(fileobject.read(6))
version = read_number(fileobject.read(2), 0)
if not magic.startswith(&amp;#34;ustar&amp;#34;):
raise ValueError(f&amp;#34;Invalid header at offset {offset}&amp;#34;)
uname = read_string(fileobject.read(32))
gname = read_string(fileobject.read(32))
devmajor = read_number(fileobject.read(8))
devminor = read_number(fileobject.read(8))
prefix = fileobject.read(155)
pad = fileobject.read(12)
return TarFile(name, mode, uid, gid, size, mtime, checksum, typeflag,
linkname, magic, version, uname, gname, devmajor, devminor,
prefix, offset &amp;#43; BLOCK_SIZE, offset)
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>Essa função acima só vai ler o header. Depois do header vem o arquivo.&lt;/p>
&lt;p>E é isso. O necessário para ler o formato está descrito&lt;/p>
&lt;p>Se você quiser, você pode transformar esse código que eu mostrei em um parser de arquivo &lt;code>.tar&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>Você pode simplesmente usar &lt;code>open&lt;/code> para ler um arquivo &lt;code>tar&lt;/code> puro. O método &lt;code>TarFile.from_file&lt;/code>
aceita um objeto de arquivo que a função &lt;code>open&lt;/code> retorna&lt;/li>
&lt;li>Para ler um arquivo &lt;code>.tar.gz&lt;/code>, use a classe &lt;code>GzipFile&lt;/code> para ler o arquivo, já que esse é o
formato que o tar está comprimido&lt;/li>
&lt;li>Outros formatos têm outras bibliotecas de suporte. Se você quiser, pode suportá-las.&lt;/li>
&lt;li>Lembre-se que dois blocos vazios, cheios de 0, identificam o final do arquivo&amp;hellip;&lt;/li>
&lt;li>Converta esse código para a sua linguagem favorita&lt;/li>
&lt;/ul>
&lt;h1 id="referências">Referências:&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/tar/manual/html_node/Standard.html">https://www.gnu.org/software/tar/manual/html_node/Standard.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/tar/manual/html_chapter/Formats.html#Compression">https://www.gnu.org/software/tar/manual/html_chapter/Formats.html#Compression&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Formatinhos: BMP - Parte 3: Layout do pixel</title><link>https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-3/</link><pubDate>Mon, 15 Aug 2022 08:59:20 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-3/</guid><description>Na primeira parte, aprendemos o básico sobre como ler um arquivo de bitmap.
Na segunda parte, aprendemos a ler bitmaps com diferentes densidades de pixel.
Agora, iremos ver diferentes densidades de pixel.
Densidades de pixel Por padrão, o arquivo de bitmap possui uma densidade e organização padrão para o pixel.
As funções getColors da parte anterior mostram isso.
Porém, alguns programas podem mudar essa ordem, por exemplo, para otimizar certas cores.</description><content>&lt;p>Na &lt;a href="https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-1/">primeira parte&lt;/a>, aprendemos o básico sobre como
ler um arquivo de bitmap.&lt;/p>
&lt;p>Na &lt;a href="https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/">segunda parte&lt;/a>, aprendemos a ler bitmaps com
diferentes densidades de pixel.&lt;/p>
&lt;p>Agora, iremos ver diferentes densidades de pixel.&lt;/p>
&lt;h1 id="densidades-de-pixel">Densidades de pixel&lt;/h1>
&lt;p>Por padrão, o arquivo de bitmap possui uma densidade e organização padrão para o pixel.&lt;br>
As funções &lt;code>getColors&lt;/code> da parte anterior mostram isso.&lt;/p>
&lt;p>Porém, alguns programas podem mudar essa ordem, por exemplo, para otimizar certas cores. O arquivo
que tem a &amp;ldquo;compressão&amp;rdquo; &lt;code>BITFIELDS&lt;/code> possui essa capacidade.&lt;/p>
&lt;p>Essa ordem é especificada em um tipo de valor chamado de &amp;lsquo;bitmask&amp;rsquo;.&lt;/p>
&lt;h2 id="bitmask">Bitmask&lt;/h2>
&lt;p>Vem do inglês e significa, literalmente, &lt;em>máscara de bits&lt;/em>. É basicamente um jeito de &amp;ldquo;cortar&amp;rdquo; um
valor: bits 1 são mantidos e bits 0 sao cortados. Por exemplo:&lt;/p>
&lt;blockquote>
&lt;p>Valor: 42069&lt;br>
Máscara: 496&lt;/p>
&lt;/blockquote>
&lt;p>Convertemos esses valores para binário&lt;/p>
&lt;p>&lt;code>Valor__: 1010 0100 0101 0101&lt;/code>&lt;br>
&lt;code>Máscara: 0000 0001 1111 0000&lt;/code>&lt;/p>
&lt;p>Fazemos uma operação AND. Isso significa que, se os dois valores forem &lt;code>1&lt;/code>, o resultado será &lt;code>1&lt;/code>,
do contrário o resultado será &lt;code>0&lt;/code>.&lt;/p>
&lt;p>&lt;code>Valor resultante: 0000 0000 0101 0000&lt;/code>&lt;/p>
&lt;p>Convertemos de volta para decimal:&lt;/p>
&lt;blockquote>
&lt;p>Valor resultante: 80&lt;/p>
&lt;/blockquote>
&lt;p>Além disso, iremos fazer mais uma operação, a operação de shifting. Contamos quantos bits temos
até o primeiro valor 1 e shiftamos esse valor para a direita.&lt;/p>
&lt;p>No caso, o valor é 4.&lt;/p>
&lt;p>&lt;code>Valor final: 0000 0000 0101 0000&lt;/code> &amp;raquo; 4 = &lt;code>0000 0000 0000 0101&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>Valor final: 5&lt;/p>
&lt;/blockquote>
&lt;h2 id="leitura">Leitura&lt;/h2>
&lt;p>Agora que você já sabe como a operação de bitmask funciona, iremos ler esse valor.&lt;/p>
&lt;p>Logo depois do header DIB (lembre-se da parte 1), se a compressão for &lt;code>BITFIELDS&lt;/code>, temos quatro
campos a mais:&lt;/p>
&lt;pre tabindex="0">&lt;code>00000020 00 00 00 00 10 00 d7 0d 00 00 d7 0d 00 00 [00 00 |................|
00000030 00 00 00 00 00 00 00 00 ff 00 00 ff 00 00 ff 00 |................|
00000040 00 00 00 00 00 ff] 00 00 00 00 00 00 00 00 00 00 |................|
00000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Posição&lt;/th>
&lt;th>Tamanho&lt;/th>
&lt;th>Campo&lt;/th>
&lt;th>Valor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;em>&lt;code>0x20 (32)&lt;/code>&lt;/em>&lt;/td>
&lt;td>&lt;em>4&lt;/em>&lt;/td>
&lt;td>&lt;em>biClrUsed&lt;/em>&lt;/td>
&lt;td>&lt;em>&lt;code>0&lt;/code>&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>&lt;code>0x24 (36)&lt;/code>&lt;/em>&lt;/td>
&lt;td>&lt;em>4&lt;/em>&lt;/td>
&lt;td>&lt;em>biClrImportant&lt;/em>&lt;/td>
&lt;td>&lt;em>&lt;code>0&lt;/code>&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x28 (40)&lt;/td>
&lt;td>4&lt;/td>
&lt;td>bV5RedMask&lt;/td>
&lt;td>&lt;code>00 00 ff 00&lt;/code> (0x00ff_0000)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x2c (44)&lt;/td>
&lt;td>4&lt;/td>
&lt;td>bV5GreenMask&lt;/td>
&lt;td>&lt;code>00 ff 00 00&lt;/code> (0x0000_ff00)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x30 (48)&lt;/td>
&lt;td>4&lt;/td>
&lt;td>bV5BlueMask&lt;/td>
&lt;td>&lt;code>ff 00 00 00&lt;/code> (0x0000_00ff)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x34 (52)&lt;/td>
&lt;td>4&lt;/td>
&lt;td>bV5AlphaMask&lt;/td>
&lt;td>&lt;code>00 00 00 ff&lt;/code> (0xff00_0000)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>O tamanho desses valores é sempre 32 bits, mas ele é usado para extrair valores em densidades
de bits menores. Você simplesmente ignora os outros bits.&lt;/p>
&lt;p>O &lt;code>red mask&lt;/code> é usado para extrair o vermelho, o &lt;code>green&lt;/code> é usado pra extrair o verde, o &lt;code>blue&lt;/code> é
usado para extrair o azul e o &lt;code>alpha&lt;/code> é usado para extrair o canal de transparência.&lt;/p>
&lt;p>Por padrão, cada pixel é organizado desse jeito:&lt;/p>
&lt;p>16 bits:&lt;/p>
&lt;pre tabindex="0">&lt;code>15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
- R R R R R G G | G G G B B B B B
&lt;/code>&lt;/pre>&lt;p>24 bits:&lt;/p>
&lt;pre tabindex="0">&lt;code>------------------------| 23 22 21 20 19 18 17 16
- - - - - - - - | R R R R R R R R
15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
G G G G G G G G | B B B B B B B B
&lt;/code>&lt;/pre>&lt;p>32 bits:&lt;/p>
&lt;pre tabindex="0">&lt;code>31 30 29 28 27 26 25 24 | 23 22 21 20 19 18 17 16
- - - - - - - - | R R R R R R R R
15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
G G G G G G G G | B B B B B B B B
&lt;/code>&lt;/pre>&lt;p>Traduzir isso para bitmasks será um exercício para o leitor.&lt;/p>
&lt;p>Em código, a leitura e interpretação das bitmasks é a seguinte:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="165937482" type="checkbox" />
&lt;label for="165937482">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing da máscara de bits&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function openDIBHeader(buffer) {
/* ... */
const dibHeader = {
compression: parseCompression(get32(buffer, 30)),
bitmapSize: get32(buffer, 34),
horizontalRes: get32(buffer, 38),
verticalRes: get32(buffer, 42),
paletteColors: get32(buffer, 46),
importantColors: get32(buffer, 50)
};
/* adicione essa linha aqui: */
const headerBitfields = {
red: get32(buffer, 54),
green: get32(buffer, 58),
blue: get32(buffer, 62),
alpha: get32(buffer, 66),
}
/* é esse código acima que você tem que botar */
return {
size: headerSize,
...baseHeader,
...(headerSize &amp;gt;= 40 ? dibHeader : {}),
// isso aqui embaixo também:
bitfields: (dibHeader.compression === &amp;#39;bitfields&amp;#39; ? headerBitfields : null)
}
}
/* Pega a bitmask e te diz quanto você precisa shiftar e em qual valor
* você precisa dar AND para ter o valor de cor baseado na bitmask
*
* Não é o jeito mais otimizado de fazer isso, mas é um jeito correto.
*/
function bitmaskIntoShiftAndMask(bitmask) {
let shift = 0;
let mask = bitmask;
while (!(mask &amp;amp; 0x1)) {
if (mask === 0)
break;
mask = mask &amp;gt;&amp;gt;&amp;gt; 1;
shift&amp;#43;&amp;#43;;
}
return { shift, mask };
}
/* Pega a bitmask dos quatro canais */
function getBitmasks(bitfields) {
if (!bitfields)
return null;
return {
r: bitmaskIntoShiftAndMask(bitfields.red),
g: bitmaskIntoShiftAndMask(bitfields.green),
b: bitmaskIntoShiftAndMask(bitfields.blue),
a: bitmaskIntoShiftAndMask(bitfields.alpha),
}
}
/* Meio auto-explicativo essa :P */
function getValueFromBitmask(value, { shift, mask }) {
return (value &amp;gt;&amp;gt;&amp;gt; shift) &amp;amp; mask;
}
/**
* Vou deixar como exemplo uma das densidades de cor aqui, para você ver como
* extrair a cor do pixel baseados nas bitmasks.
*
* O parâmetro bitmask tem como formato o resultado da função getBitmasks()
*
* As outras densidades ficam a seu cargo implementar, se você quiser
*/
function getColors32(y, x, buffer, pixelpos, bitmask) {
const value = get32(buffer, pixelpos(y, x));
const bits = getBitmasks(bitmask);
const r = getValueFromBitmask(value, bits.r);
const g = getValueFromBitmask(value, bits.g);
const b = getValueFromBitmask(value, bits.b);
// Se não tiver alfa, faz ele ser completamente opaco.
const a = bits.a.mask ? getValueFromBitmask(value, bits.a) : 0xff;
// format RGBA
return [
r, g, b, a
];
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;hr>
&lt;p>E concluimos esse formato. Por enquanto.&lt;/p>
&lt;p>O próximo formato sai daqui a alguns dias, e o repositório com um parser BMP em Javascript
sai também daqui a uns dias&lt;/p>
&lt;p>Vou começar a estudar a compressão RLE, mas ela vai vir mais como um bônus.&lt;/p></content></item><item><title>Formatinhos: BMP - Parte 2: Outras profundidades de cor</title><link>https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/</link><pubDate>Sun, 14 Aug 2022 14:40:54 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-2/</guid><description>Na primeira parte, aprendemos o básico sobre como ler um arquivo de bitmap.
Mas nós lemos apenas uma profundidade de cor
Nesse post, aprenderemos a ler as outras profundidades
O arquivo bitmap suporta 6 profundidades de cor: 32bpp, 24bpp, 16bpp, 8bpp, 4bpp, e 1bpp.
Elas são divididas em três grupos:
16 bpp e maiores têm as informações de cor escritas diretamente no array de pixels. 8 bpp e menores têm, no lugar das cores, um índice para uma paleta de cores, que fica entre o header DIB e o array de pixels.</description><content>&lt;p>Na &lt;a href="https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-1/">primeira parte&lt;/a>, aprendemos o básico sobre como
ler um arquivo de bitmap.&lt;/p>
&lt;p>Mas nós lemos apenas uma profundidade de cor&lt;/p>
&lt;p>Nesse post, aprenderemos a ler as outras profundidades&lt;/p>
&lt;p>O arquivo bitmap suporta 6 profundidades de cor: 32bpp, 24bpp, 16bpp, 8bpp, 4bpp, e 1bpp.&lt;/p>
&lt;p>Elas são divididas em três grupos:&lt;/p>
&lt;ul>
&lt;li>16 bpp e maiores têm as informações de cor escritas diretamente no array de pixels.&lt;/li>
&lt;li>8 bpp e menores têm, no lugar das cores, um índice para uma paleta de cores, que fica entre
o header DIB e o array de pixels.&lt;/li>
&lt;/ul>
&lt;p>As três primeiras são &lt;em>bem fáceis&lt;/em>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="743659812" type="checkbox" />
&lt;label for="743659812">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing dos pixels por profundidade de cor&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function getColors32(y, x, buffer, pixelpos) {
// format RGBA
return [
get8(buffer, pixelpos(y, x) &amp;#43; 2),
get8(buffer, pixelpos(y, x) &amp;#43; 1),
get8(buffer, pixelpos(y, x) &amp;#43; 0),
0xff
];
}
function getColors24(y, x, buffer, pixelpos) {
// format RGBA
return [
get8(buffer, pixelpos(y, x) &amp;#43; 2),
get8(buffer, pixelpos(y, x) &amp;#43; 1),
get8(buffer, pixelpos(y, x) &amp;#43; 0),
0xff
];
}
function getColors16(y, x, buffer, pixelpos) {
const value = get16(buffer, pixelpos(y, x));
const cast16to24 = (v) =&amp;gt; Math.floor(v / 32 * 255);
const b = cast16to24((value &amp;gt;&amp;gt;&amp;gt; 0) &amp;amp; 0x1f);
const g = cast16to24((value &amp;gt;&amp;gt;&amp;gt; 5) &amp;amp; 0x1f);
const r = cast16to24((value &amp;gt;&amp;gt;&amp;gt; 10) &amp;amp; 0x1f);
return [r, g, b, 0xff];
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;blockquote>
&lt;p>(Juntar essas funções no código anterior fica como um exercício para o leitor. Mas &lt;em>não é difícil&lt;/em>.
É só prestar atenção no conteúdo das funções.)&lt;/p>
&lt;/blockquote>
&lt;p>A mais complicada é 16bpp, já que, nela, cada canal de cor tem menos do que um byte.&lt;/p>
&lt;p>Antes de falar dos canais com profundidade de cor menor, eu preciso falar da &lt;strong>paleta&lt;/strong>&lt;/p>
&lt;h1 id="paleta">Paleta&lt;/h1>
&lt;p>Obrigatoriamente, se a profundidade de cor de sua imagem for menor ou igual a 8 bits por pixel, a
paleta será sempre definida.&lt;/p>
&lt;p>O tamanho da paleta é definida pelo campo &lt;code>blClrUsed&lt;/code> (definida no código como &lt;code>paletteColors&lt;/code>).&lt;br>
Se ele for 0, e a imagem tiver 8 bits por pixel ou menor, é a quantidade máxima permitida (2
elevado a quantidade de bits por pixel).&lt;br>
Se ele for maior que 0, a quantidade de cores ali vai ser o tamanho da paleta.&lt;/p>
&lt;p>Logo depois do header (ou seja, você vai até o começo do header e soma &lt;code>biSize&lt;/code>), teremos um array
de pixels em formato BGRX. &lt;br>
Isso significa que primeiro vem o azul, depois verde, depois vermelho e depois um byte de &lt;em>padding&lt;/em>,
que &lt;strong>não é o canal alfa&lt;/strong>.&lt;/p>
&lt;p>Pra quem parseou um header, ler essas cores é muito simples. É a mesma coisa que ler o array de
pixels, na verdade.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="158369427" type="checkbox" />
&lt;label for="158369427">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing da paleta de cores&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function getColorTable(header, buffer) {
if (header.dibHeader.bpp &amp;gt; 8)
return null;
const colorTableOffset = header.fileHeaderSize &amp;#43; header.dibHeader.size;
const tableSize = (header.dibHeader.paletteColors === 0 ) ?
2 ** header.dibHeader.bpp :
header.dibHeader.paletteColors;
let table = [];
const getColor = (i) =&amp;gt; {
const off = colorTableOffset &amp;#43; (i * 4);
return {
b: get8(buffer, off),
g: get8(buffer, off &amp;#43; 1),
r: get8(buffer, off &amp;#43; 2),
a: get8(buffer, off &amp;#43; 3)
};
}
for (let i = 0; i &amp;lt; tableSize; i&amp;#43;&amp;#43;) {
table.push(getColor(i));
}
return table;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h1 id="as-profundidades-de-cor-finais">As profundidades de cor finais&lt;/h1>
&lt;p>Agora que você tem a tabela de cores, ler os outros formatos fica muito mais fácil.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="391648572" type="checkbox" />
&lt;label for="391648572">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing dos pixels por profundidade de cor II&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function getColors8(y, x, buffer, pixelpos, table) {
const { r, g, b } = table[get8(buffer, pixelpos(y, x))];
return [r, g, b, 0xff];
}
function getColors4(y, x, buffer, pixelpos, table) {
const byte = get8(buffer, pixelpos(y, x));
const value = (x % 2 == 0) ? (byte &amp;gt;&amp;gt; 4) : (byte &amp;amp; 0xf);
const { r, g, b } = table[value];
return [r, g, b, 0xff];
}
function getColors1(y, x, buffer, pixelpos, table) {
const byte = get8(buffer, pixelpos(y, x));
const bit = x % 8;
const value = (byte &amp;gt;&amp;gt; (7-bit)) &amp;amp; 1;
const { r, g, b } = table[value];
return [r, g, b, 0xff];
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Novamente, juntar essas funções vai ficar a cargo do leitor :)&lt;/p>
&lt;hr>
&lt;p>Agora, qualquer bitmap que o Paint gerar você consegue abrir. Mas e quanto os outros programas?&lt;/p>
&lt;p>Você deve ter reparado que, por exemplo, alguns bitmaps salvos pelo Gimp não conseguem ser abertos
corretamente. Isso porque eles usam um método de &amp;ldquo;compressão&amp;rdquo; (que não é compressão, é só a
definição do formato) chamado &lt;code>BITFIELDS&lt;/code>. Esse método nos permite especificar exatamente quanto de
verde, vermelho e azul a imagem vai ter,&lt;/p>
&lt;p>Na próxima parte, iremos ler as informações de bitfields do arquivo de bitmap.&lt;/p>
&lt;h1 id="referências">Referências&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/pt-br/windows/win32/gdi/bitmap-storage">https://docs.microsoft.com/pt-br/windows/win32/gdi/bitmap-storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7903#section-1.2">https://datatracker.ietf.org/doc/html/rfc7903#section-1.2&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Formatinhos: BMP - Parte 1: Abrindo um bitmap</title><link>https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-1/</link><pubDate>Fri, 12 Aug 2022 14:26:18 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/formatinhos-bmp-parte-1/</guid><description>O primeiro episódio da série começa com um dos formatos de imagens historicamente mais fáceis de parsear.
Isso é bom, já que eu posso testar a qualidade da minha explicação e ir melhorando conforme os formatos forem ficando cada vez mais complexos.
O formato de arquivos BMP (bitmap, literalmente mapa de bits) é um dos formatos mais antigos de armazenamento de imagens, criado para que máquinas mais fracas pudessem renderizar imagens com facilidade.</description><content>&lt;p>O primeiro episódio da série começa com um dos formatos de imagens historicamente mais fáceis de
parsear.&lt;br>
Isso é bom, já que eu posso testar a qualidade da minha explicação e ir melhorando conforme
os formatos forem ficando cada vez mais complexos.&lt;/p>
&lt;p>O formato de arquivos BMP (bitmap, literalmente &lt;em>mapa de bits&lt;/em>) é um dos formatos mais antigos de
armazenamento de imagens, criado para que máquinas mais fracas pudessem renderizar imagens com
facilidade. Ele foi criado pela Microsoft e pela IBM para os x86. Portanto, todas as estruturas
estão em &lt;em>little endian&lt;/em>, já que o x86 é &lt;em>little endian&lt;/em>.&lt;/p>
&lt;p>Você provavelmente já criou um arquivo BMP quando você era criança, já que era o formato principal
do &lt;strong>PaintBrush&lt;/strong>, do Windows 7 pra trás.&lt;/p>
&lt;p>Ele também é, se você usar os modos de cor e implementação padrões, um dos formatos mais fáceis
de fazer &lt;em>parsing&lt;/em>.&lt;/p>
&lt;p>Ele suporta até 32 bits de cor por pixel (bpp), embora os formatos mais comuns sejam 24, 8 e 1bpp.
Inicialmente, iremos fazer o parsing de arquivos com 24 bits por pixel, depois expandiremos para
as outras profundidades de cor.&lt;/p>
&lt;p>O arquivo BMP também suporta alguns métodos de organização de pixel que ele chama de &lt;em>compressão&lt;/em>,
embora nem todos sejam compressão:&lt;/p>
&lt;ul>
&lt;li>RGB&lt;/li>
&lt;li>RLE (apenas com 8 e 4 bpp)&lt;/li>
&lt;li>BITFIELDS (uma máscara de bits define onde ficam as cores)&lt;/li>
&lt;li>JPEG&lt;/li>
&lt;li>PNG&lt;/li>
&lt;/ul>
&lt;p>Destes, os programas que eu uso apenas escrevem arquivos com &lt;strong>RGB&lt;/strong> e &lt;strong>BITFIELDS&lt;/strong>.&lt;br>
Eu achei um programa &lt;em>bem&lt;/em> antigo que suporta RLE8, mas eu ainda não consegui fazer ele rodar.
Quando eu conseguir, a gente adiciona RLE8 na lista de formatos suportados.&lt;/p>
&lt;p>Mas, por ora, apenas RGB e BITFIELDS. RGB primeiro.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://arthurmco.github.io/blog/blog/images/formats/bmp/paint.png" />
&lt;figcaption class="center" >PaintBrush, o maior popularizador dos arquivos BMP. Fonte: bc-programming.com&lt;/figcaption>
&lt;/figure>
&lt;p>Para iniciarmos, vá até &lt;a href="https://github.com/arthurmco/formatties-base">esse repositório&lt;/a>, baixe
os arquivos da pasta &amp;ldquo;bmp&amp;rdquo;, vá até a pasta e rode o &lt;code>npm install&lt;/code>&lt;/p>
&lt;p>Depois disso, iremos começar.&lt;/p>
&lt;h1 id="file-header">File Header&lt;/h1>
&lt;p>No arquivo BMP, o &lt;em>header&lt;/em> é uma das primeiras informações.&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 42 4d 56 cc 0a 00 00 00 00 00 36 00 00 00 28 00 |BMV.......6...(.|
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Posição&lt;/th>
&lt;th>Tamanho&lt;/th>
&lt;th>Campo&lt;/th>
&lt;th>Valor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>0x0 (0)&lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>bfType&lt;/td>
&lt;td>&lt;code>42 4d&lt;/code> = &lt;code>BM&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x2 (2)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>bfSize&lt;/td>
&lt;td>&lt;code>0xACC56&lt;/code> = 707670&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x6 (6)&lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>bfReserved1&lt;/td>
&lt;td>&lt;code>00 00&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x8 (8)&lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>bfReserved2&lt;/td>
&lt;td>&lt;code>00 00&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xA (10)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>bfOffBits&lt;/td>
&lt;td>&lt;code>0x36&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>O campo &lt;code>bfType&lt;/code> é o nosso &amp;ldquo;Header&amp;rdquo;. Existem vários formatos, mas nós só vamos nos concentrar
no &amp;ldquo;BM&amp;rdquo;, que significa &amp;ldquo;&lt;strong>B&lt;/strong>it&lt;strong>M&lt;/strong>ap&amp;rdquo;.&lt;/li>
&lt;li>O &lt;code>bfSize&lt;/code> é o tamanho do arquivo. (Pode conferir se você quiser :P)&lt;/li>
&lt;li>Os dois reservados são, bem, reservados para o aplicativo que criou o arquivo, e nós devemos
ignorar&lt;/li>
&lt;li>O &lt;code>bfOffBits&lt;/code> mostra a posição (ou offset) do bitmap, dos &amp;ldquo;pixels&amp;rdquo; da imagem, a partir do começo
do arquivo&lt;/li>
&lt;/ul>
&lt;p>Nós vamos ler esse header da seguinte forma: crie um arquivo na pasta &lt;code>src&lt;/code> chamado de
&lt;code>bmp.js&lt;/code>. Toda nossa lógica de parsing de bitmap ficará nesse arquivo&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="597418623" type="checkbox" />
&lt;label for="597418623">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing do header do arquivo bitmap&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
/* Funções auxiliares para ler valores de 1, 2 e 4 bytes
* Endianness ignorada por simplicidade */
const get8 = (buffer, index) =&amp;gt; buffer[index];
const get16 = (buffer, index) =&amp;gt; (buffer[index] | (buffer[index&amp;#43;1] &amp;lt;&amp;lt; 8));
const get32 = (buffer, index) =&amp;gt; (get16(buffer, index) | get16(buffer, index&amp;#43;2) &amp;lt;&amp;lt; 16);
const hasBMPHeader = (buffer) =&amp;gt; get16(buffer, 0) == 0x4d42;
function openBMPHeader(buffer) {
if (!hasBMPHeader(buffer))
return null;
// Nós só pegamos apenas o que precisamos.
//
// É importante pegar o tamanho do header, já que o próximo header vai vir logo depois
// desse, e uma tabela de cores opcional virá logo depois desses dois. Saber onde estamos
// é muito importante!
return {
fileHeaderSize: 14,
bmpSize: get32(buffer, 2),
pixelDataOffset: get32(buffer, 10)
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h1 id="dib-header">DIB Header&lt;/h1>
&lt;p>O &lt;em>header DIB&lt;/em> vem logo depois do &lt;em>header do arquivo&lt;/em>, e contém informações sobre os pixels
em si.&lt;/p>
&lt;p>DIB significa &lt;em>Device Independent Bitmap&lt;/em>, ou Bitmap Independente de Dispositivo. Teoricamente
ele não vai ter diferença onde quer que você veja, seja numa tela ou numa folha.&lt;/p>
&lt;p>Existem vários tipos de headers, mas eles meio que se complementam, compartilhando campos
semelhantes. Eu vou mostrar apenas um por enquanto, que é o que o Paint suporta.&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 42 4d 56 cc 0a 00 00 00 00 00 36 00 00 00 [28 00 |BMV.......6...(.|
00000010 00 00 70 02 00 00 7a 01 00 00 01 00 18 00 00 00 |..p...z.........|
00000020 00 00 20 cc 0a 00 00 00 00 00 00 00 00 00 00 00 |.. .............|
00000030 00 00 00 00 00 00]
&lt;/code>&lt;/pre>&lt;p>O header DIB está demarcado em colchetes nesse dump. As posições (ou offsets) são relativas
ao header DIB.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Posição&lt;/th>
&lt;th>Tamanho&lt;/th>
&lt;th>Campo&lt;/th>
&lt;th>Valor&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>0x0 (0)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biSize&lt;/td>
&lt;td>&lt;code>0x28&lt;/code> = 40&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x4 (4)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biWidth&lt;/td>
&lt;td>&lt;code>0x270&lt;/code> = 624&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x8 (8)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biHeight&lt;/td>
&lt;td>&lt;code>0x17a&lt;/code> = 378&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xC (12)&lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>biPlanes&lt;/td>
&lt;td>&lt;code>0x0001&lt;/code> = 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0xE (14)&lt;/code>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>biBitCount&lt;/td>
&lt;td>&lt;code>0x0018&lt;/code> = 24&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x10 (16)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biCompression&lt;/td>
&lt;td>&lt;code>0x0&lt;/code> = &lt;code>BI_RGB&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x14 (20)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biSizeImage&lt;/td>
&lt;td>&lt;code>0xacc20&lt;/code> = 707616&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x18 (24)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biXPelsPerMeter&lt;/td>
&lt;td>&lt;code>0&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x1c (28)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biYPelsPerMeter&lt;/td>
&lt;td>&lt;code>0&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x20 (32)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biClrUsed&lt;/td>
&lt;td>&lt;code>0&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>0x24 (36)&lt;/code>&lt;/td>
&lt;td>4&lt;/td>
&lt;td>biClrImportant&lt;/td>
&lt;td>&lt;code>0&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;code>biSize&lt;/code> é o tamanho da estrutura, usado para diferenciar as diferentes versões. E a estrutura
toda menos esse campo. A versão de 40 bytes é a mais comum
&lt;ul>
&lt;li>Existe uma versão da estrutura onde &lt;code>biSize&lt;/code> = 12. Ele só vai até &lt;code>biBitCount&lt;/code>, a imagem é
RGB por padrão. Essa versão é usada pelos Windows 2.x e 3.0.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>biWidth&lt;/code> e &lt;code>biHeight&lt;/code> definem a largura e a altura, respectivamente, do bitmap, em pixels.&lt;/li>
&lt;li>Você não precisa se preocupar com &lt;code>biPlanes&lt;/code>, é uma herança da época em que a memória gráfica era
dividia em partes chamadas de planos. O valor padrão é 1.&lt;/li>
&lt;li>&lt;code>biBitCount&lt;/code> é a quantidade de bits por pixels da imagem.
&lt;ul>
&lt;li>O padrão é &lt;strong>24 bits&lt;/strong>, ou seja &lt;strong>3 bytes por pixel&lt;/strong> (1 byte pra vermelho, 1 pra verde e
1 pra azul).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>O campo &lt;code>biSizeImage&lt;/code> define a quantidade de bytes do bitmap, quanto de espaço os pixels ocupam.&lt;/li>
&lt;li>Os campos que têm &lt;code>PelsPerMeter&lt;/code> definem a resolução em pixels por metro. Geralmente esse parâmetro
é zerado.&lt;/li>
&lt;li>&lt;code>blClrUsed&lt;/code> é usado pra definir uma tabela de cores. Se o bitmap tiver 16 bits por pixel ou mais,
esse campo pode ser ignorado.&lt;/li>
&lt;li>&lt;code>blClrImportant&lt;/code> é usado pra mostrar a quantidade de cores necessárias para mostrar o bitmap.
Geralmente é 0.&lt;/li>
&lt;/ul>
&lt;p>O parsing desse header não é nada difícil. No arquivo bmp.js, adicione essas linhas, logo
depois do trecho anterior&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="489623157" type="checkbox" />
&lt;label for="489623157">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing do header DIB&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function parseCompression(val) {
if (val &amp;gt;= 4)
return null;
else
return [&amp;#34;rgb&amp;#34;, &amp;#34;rle8&amp;#34;, &amp;#34;rle4&amp;#34;, &amp;#34;bitfields&amp;#34;][val]
}
function openDIBHeader(buffer) {
const headerSize = get32(buffer, 14);
const baseHeader = {
width: get32(buffer, 18),
height: get32(buffer, 22),
planes: get16(buffer, 26),
bpp: get16(buffer, 28),
compression: &amp;#39;rgb&amp;#39;
};
const dibHeader = {
compression: parseCompression(get32(buffer, 30)),
bitmapSize: get32(buffer, 34),
horizontalRes: get32(buffer, 38),
verticalRes: get32(buffer, 42),
paletteColors: get32(buffer, 46),
importantColors: get32(buffer, 50)
};
return {
size: headerSize,
...baseHeader,
...(headerSize &amp;gt;= 40 ? dibHeader : {})
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Altere as linhas da função &lt;code>openBMPHeader&lt;/code> pra incluir o header DIB&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="743856912" type="checkbox" />
&lt;label for="743856912">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing do header DIB&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
return {
fileHeaderSize: 14,
bmpSize: get32(buffer, 2),
pixelDataOffset: get32(buffer, 10)
// Adicione essa linha aqui embaixo:
dibHeader: openDIBHeader(buffer),
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h1 id="pixels">Pixels&lt;/h1>
&lt;p>O campo &lt;code>bfOffBits&lt;/code> (no código como &lt;code>pixelDataOffset&lt;/code> pra ficar mais claro) aponta para uma lista
de pixels, organizadas desse jeito:&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/formats/bmp/pixelgrid.png" alt="Array de pixels, em formato BGR (Blue, Green, Yellow)">&lt;/p>
&lt;p>Cada quadrado dessa imagem é 1 byte. Primeiro vem o valor azul do pixel, depois o verde e depois
o vermelho, e por aí vai. Em 24 bits por pixel, o formato mais comum hoje em dia, é desse jeito aí:&lt;/p>
&lt;p>Essa lista de pixels é dividida em tiras. Cada tira tem um pixel de altura e a largura é a largura
da imagem. O começo de cada tira de pixels deve estar numa posição divisível por 4. Se não tiver,
bytes adicionais (chamados de &lt;em>padding&lt;/em> são adicionados ao final da tira.)&lt;/p>
&lt;p>O código pra ler isso não é muito difícil não.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="325879641" type="checkbox" />
&lt;label for="325879641">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing dos pixels&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
/// Pega o tamanho da tira, em bytes
const getRowSize = (header) =&amp;gt; (
(header.dibHeader.width * (header.dibHeader.bpp / 8)) &amp;#43; 3) &amp;amp; 0xfffffffc;
/**
* Faz o parsing dos pixels do arquivo BMP, retorna um array de arrays, em formato RGBA, o
* padrão do `canvas` do Javascript.
* O primeiro array é uma tira, o segundo é um pixel.
* @param {*} header
* @param {Uint8Buffer} buffer O buffer do arquivo BMP. Eu faço o comentário assim pro
* VSCode fazer o typecheck do javascript e o autocomplete funcionar direito.
* @returns
*/
function parseColors(header, buffer) {
let pixels = [];
const rowsize = getRowSize(header);
const pixeloff = header.pixelDataOffset;
// Posição do pixel.
// O Math.floor enforça uma &amp;#34;divisão inteira&amp;#34;, já que o javascript não tem um operador de divisão que
// retorne um inteiro. Isso é importante, já que não dá pra ler o byte 16.666666, é só 16 ou 17.
// Um valor floating também vai cagar a conta mais pra frente, quando formos ler cores de arrays de
// pixels menores que 1 byte.
const pixelpos = (y, x) =&amp;gt; pixeloff &amp;#43; (y * getRowSize(header)) &amp;#43; Math.floor(x * header.dibHeader.bpp/8);
for (let y = 0; y &amp;lt; header.dibHeader.height; y&amp;#43;&amp;#43;) {
let row = [];
for (let x = 0; x &amp;lt; header.dibHeader.width; x&amp;#43;&amp;#43;) {
row.push([
get8(buffer, pixelpos(y, x) &amp;#43; 2),
get8(buffer, pixelpos(y, x) &amp;#43; 1),
get8(buffer, pixelpos(y, x) &amp;#43; 0),
0xff
])
}
pixels.push(row);
}
return pixels;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h1 id="mostrando-os-valores">Mostrando os valores.&lt;/h1>
&lt;p>Agora chegou a hora de visualizar os pixels. Vamos alterar o código em dois lugares:&lt;/p>
&lt;p>Coloque isso no final do arquivo &lt;code>bmp.js&lt;/code>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="928375416" type="checkbox" />
&lt;label for="928375416">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">bmp.js: Parsing dos pixels&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function openBMPFile(buffer) {
const header = openBMPHeader(buffer);
if (!header)
return null;
return {
header,
colors: parseColors(header, buffer)
};
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>No arquivo &lt;code>index.js&lt;/code>, no lugar do &lt;code>const idata...&lt;/code>, coloque essa linha:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">idata&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">plot&lt;/span>(&lt;span style="color:#a6e22e">buffer&lt;/span>, &lt;span style="color:#a6e22e">canvas&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A função plot vai ficar assim:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="836429715" type="checkbox" />
&lt;label for="836429715">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__title">index.js: Visualização dos pixels&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
function plot(buffer, canvas) {
const file = openBMPFile(buffer);
const w = file.header.dibHeader.width;
const h = file.header.dibHeader.height;
let imagedata = canvas.createImageData(w, h);
for (let y = 0; y &amp;lt; h; y&amp;#43;&amp;#43; ) {
for (let x = 0; x &amp;lt; w; x&amp;#43;&amp;#43;) {
const pos = (y*w*4) &amp;#43; (x*4);
imagedata.data[pos] = file.colors[y][x][0];
imagedata.data[pos&amp;#43;1] = file.colors[y][x][1];
imagedata.data[pos&amp;#43;2] = file.colors[y][x][2];
imagedata.data[pos&amp;#43;3] = file.colors[y][x][3];
}
}
return imagedata;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Agora a imagem vai funcionar&amp;hellip;&lt;/p>
&lt;p>Ou &lt;em>quase&lt;/em>.&lt;/p>
&lt;p>Você deve ter reparado que a imagem está de ponta cabeça. No formato BMP, a primeira &amp;ldquo;tira&amp;rdquo; do arquivo
fica embaixo, e a última fica em cima.&lt;/p>
&lt;p>Existe um fix para isso, e é &lt;em>super&lt;/em> fácil, mas eu vou deixar como um exercício para o leitor.&lt;/p>
&lt;h1 id="parte-2">Parte 2&lt;/h1>
&lt;p>Você pode reparar que você consegue abrir quase todos os tipos de arquivos que o Paint gera.&lt;/p>
&lt;p>&lt;em>Quase&lt;/em>.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/formats/bmp/others.png" alt="Nós só suportamos apenas 24bpp. E esses outros?">&lt;/p>
&lt;p>Nós só suportamos o &amp;ldquo;Bitmap de 24 bits&amp;rdquo; até agora.&lt;/p>
&lt;p>Tente importar os outros formatos. Veja o que acontece.&lt;/p>
&lt;p>Na próxima parte iremos ver como se abrem esses outros formatos de cor. Felizmente, todos são
&amp;ldquo;rgb&amp;rdquo;, mas eles têm diferentes &lt;strong>densidades de pixel&lt;/strong>&lt;/p>
&lt;h1 id="referências">Referências&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/pt-br/windows/win32/gdi/bitmap-storage">https://docs.microsoft.com/pt-br/windows/win32/gdi/bitmap-storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7903#section-1.2">https://datatracker.ietf.org/doc/html/rfc7903#section-1.2&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>