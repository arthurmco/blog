<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tips on Blog do Arthur M.</title><link>https://arthurmco.github.io/blog/tags/tips/</link><description>Recent content in tips on Blog do Arthur M.</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Thu, 04 Aug 2022 20:07:38 -0300</lastBuildDate><atom:link href="https://arthurmco.github.io/blog/tags/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>Meu disquete não tá lendo!</title><link>https://arthurmco.github.io/blog/posts/meu-disquete-nao-ta-lendo-no-linux/</link><pubDate>Thu, 04 Aug 2022 20:07:38 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/meu-disquete-nao-ta-lendo-no-linux/</guid><description>Há alguns dias atrás, eu consegui um teclado de música usado, um Yamaha PSR-350 pra aprender a tocar música, já que era algo que eu sempre quis aprender. O que faltava, na real, era dinheiro pra comprar algum instrumento.
Não é um teclado muito novo, mas também não é muito antigo: é de algum lugar dos anos 2000.
O teclado aí. Fonte: fr.audiofanzine.com Uma das coisas que me chamou a atenção foi o fato de ele ter um belo leitor de disquetes, pra você poder salvar suas músicas pra tocar no PC, ou pra transmitir músicas pra tocá-las no teclado.</description><content>&lt;p>Há alguns dias atrás, eu consegui um teclado de música usado, um Yamaha PSR-350 pra aprender a
tocar música, já que era algo que eu sempre quis aprender. O que faltava, na real, era dinheiro pra
comprar algum instrumento.&lt;/p>
&lt;p>Não é um teclado muito novo, mas também não é muito antigo: é de algum lugar dos anos 2000.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://arthurmco.github.io/blog/blog/images/key/yamaha-psr-350.jpg" />
&lt;figcaption class="center" >O teclado aí. Fonte: fr.audiofanzine.com&lt;/figcaption>
&lt;/figure>
&lt;p>Uma das coisas que me chamou a atenção foi o fato de ele ter um belo leitor de disquetes, pra você
poder salvar suas músicas pra tocar no PC, ou pra transmitir músicas pra tocá-las no teclado.&lt;/p>
&lt;p>Depois de algumas semanas esperando meu leitor de disquete USB chegar da China, eu pude testá-lo com
alguns disquetes que eu tinha comprado.&lt;/p>
&lt;p>Infelizmente, para minha surpresa, o disco mostrou uma mensagem nada amigável.&lt;/p>
&lt;pre tabindex="0">&lt;code>[ 1780.060701] sd 7:0:0:0: [sdc] Attached SCSI removable disk
[ 1827.483175] sd 7:0:0:0: [sdc] Read Capacity(10) failed: Result: hostbyte=DID_OK driverbyte=DRIVER_SENSE
[ 1827.483178] sd 7:0:0:0: [sdc] Sense Key : Medium Error [current]
[ 1827.483179] sd 7:0:0:0: [sdc] Add. Sense: Cannot read medium - unknown format
&lt;/code>&lt;/pre>&lt;p>Claro que eu pensei que o leitor estava quebrado.&lt;/p>
&lt;p>Porém, como ele estaria quebrado se ele foi reconhecido? Provavelmente era algum problema com o
disquete que eu usei.&lt;/p>
&lt;p>Então eu tentei outro, novinho em folha. Mesmo erro.&lt;/p>
&lt;hr>
&lt;p>Irei poupar a vocês as horas de pesquisa vendo fóruns e mais fóruns, e lhes mostrar direto o que
eu fiz pra resolver:&lt;/p>
&lt;p>O problema era que o disquete não estava formatado em &lt;strong>baixo nível&lt;/strong>.&lt;/p>
&lt;p>Você deve ter reparado, caso você tenha uns 30 e poucos anos no mínimo, que um disquete de 720KB ou
1.44MB podia ser usado em várias arquiteturas de computador diferente, mas eles eram incompatíveis
entre si: um disquete no PC não funcionava no Apple II e vice-versa.&lt;/p>
&lt;p>Isso se devia ao fato que esses sistemas esperavam que &lt;em>os setores estivessem em lugares diferentes
do disco&lt;/em>.&lt;/p>
&lt;p>O disquete é uma mídia dividida em &lt;em>cabeças&lt;/em>, &lt;em>trilhas&lt;/em> e &lt;em>setores&lt;/em> (heads, tracks e
sectors). Um disquete de 1.44 MB contém 2 cabeças, 80 trilhas e 18 setores por trilha,
cada setor tendo 512 bytes.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://arthurmco.github.io/blog/blog/images/key/heads.jpg" />
&lt;figcaption class="center" >Como o disquete é organizado fisicamente. Fonte: researchgate.net&lt;/figcaption>
&lt;/figure>
&lt;p>A quantidade de cabeças é pré-definida, mas, em alguns discos, as trilhas e os setores, não são. Eles
são definidos por software, em padrões de bits gravados no disquete que informam onde a trilha começa e
o tamanho de cada setor. Essa definição é chamada de &lt;em>formatação de baixo-nível&lt;/em>, ou &lt;em>low-level formatting&lt;/em>&lt;/p>
&lt;p>O problema é que os disquetes que eu comprei não tinham esses padrões de bits, eles não estavam
&amp;ldquo;formatados&amp;rdquo;.&lt;/p>
&lt;h2 id="solucionando">Solucionando&lt;/h2>
&lt;p>Para você fazer isso no Linux, você deve baixar um utilitário chamado ufiformat.
&lt;a href="https://github.com/tedigh/ufiformat">O link para o repositório&lt;/a>.&lt;/p>
&lt;p>Ele não está compilado, mas compilar é tranquilo: instale o pacote &lt;code>e2fs-progs&lt;/code> para compilar
(deve ser algo chamado &lt;code>e2fsprogs-dev&lt;/code> no Debian e derivados), depois é só dar &lt;code>./configure&lt;/code> e
&lt;code>make&lt;/code>.&lt;/p>
&lt;p>Para listar os dispositivos disponíveis, digite &lt;code>./ufiformat -i&lt;/code>.&lt;/p>
&lt;p>Para rodar, digite &lt;code>./ufiformat -V -v /dev/&amp;lt;teu disquete&amp;gt;&lt;/code>. Ele vai rodar e depois verificar para
ver se deu certo.&lt;br>
Depois que ele terminar, tire o disquete e coloque denovo.&lt;br>
Se isso daqui aparecer no &lt;code>dmesg&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[ 2213.047066] usb 3-4: reset full-speed USB device number 8 using xhci_hcd
[ 2213.273042] sd 7:0:0:0: Power-on or device reset occurred
[ 2214.872958] sd 7:0:0:0: [sdc] 2880 512-byte logical blocks: (1.47 MB/1.41 MiB)
[ 2321.016219] sdc:
&lt;/code>&lt;/pre>&lt;p>significa que deu certo.&lt;/p>
&lt;h1 id="e-no-windows">E no Windows?&lt;/h1>
&lt;p>No Windows é mais fácil que parece.&lt;/p>
&lt;p>Quando você inserir o disquete, ele vai dar uma mensagem de erro dizendo que o disco pode não estar
formatado.&lt;/p>
&lt;p>Você pode achar que ele está falando do sistema de arquivos, mas ele está falando mesmo da definição
de setores, do low level.&lt;/p>
&lt;p>Clique com o botão direito no disquete e vá em &amp;ldquo;Formatar&amp;rdquo;. Uma janela assim vai aparecer:&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/key/winformat.png" alt="A janela te pedindo pra formatar">&lt;/p>
&lt;p>Sabe essa opção &amp;ldquo;Formatação Rápida&amp;rdquo;? &lt;strong>Não marque ela.&lt;/strong> Se ela tiver selecionada, &lt;strong>desmarque&lt;/strong>.
Se você selecionar, ela não vai formatar o disquete em baixo nível.&lt;/p>
&lt;p>Clique em Iniciar e espere uns minutinhos.&lt;/p>
&lt;p>Depois disso, corre pro abraço!&lt;/p></content></item><item><title>TravaZap e TravaLoL: como funcionam? - Parte 1</title><link>https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/</link><pubDate>Fri, 29 Jul 2022 04:36:31 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/trava-zap-trava-lol/</guid><description>Esse é o primeiro de uma categoria de posts que eu vou fazer chamada de &amp;ldquo;direcionados para todos os públicos.&amp;rdquo;
Por causa disso, as coisas serão explicadas com mais detalhes, já que nem todos entendem os termos técnicos. Se você achar que eu estou falando muito, é por isso.
Além disso, as explicações que eu vou dar não são para alguém com doutorado em ciências da computação entender, mas sim para sua tia que tomou o travazap do rei do PIX saber o porquê do celular dela ficar lento.</description><content>&lt;p>Esse é o primeiro de uma categoria de posts que eu vou fazer chamada de
&amp;ldquo;direcionados para todos os públicos.&amp;rdquo;&lt;/p>
&lt;p>Por causa disso, as coisas serão explicadas com mais detalhes, já que nem todos
entendem os termos técnicos. Se você achar que eu estou falando muito, é por isso.&lt;/p>
&lt;p>Além disso, as explicações que eu vou dar não são para alguém com doutorado em ciências
da computação entender, mas sim para sua tia que tomou o travazap do rei do PIX saber
o porquê do celular dela ficar lento. Então não seja chato de falar que eu esqueci de
falar alguma coisa. Eu simplifiquei alguns termos para que a mensagem fique mais clara.&lt;/p>
&lt;p>Dito isso, vamos lá:&lt;/p>
&lt;hr>
&lt;p>Ultimamente os jogadores de League of Legends têm reclamado de um tal de &lt;strong>travalol&lt;/strong>, ou &lt;strong>trava lobby&lt;/strong>,
uma espécie de programa que faz com que os jogadores sejam &lt;em>kickados&lt;/em> das partidas.&lt;/p>
&lt;p>No vídeo abaixo você pode ver um vídeo do canal &amp;ldquo;Que Crime&amp;rdquo; falando um pouco do Travalol:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/LdK4C5ANZXI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h1 id="uma-explicação-básica">Uma explicação básica&lt;/h1>
&lt;blockquote>
&lt;p>O TravaZap funciona porque a mensagem do trava contém caracteres especiais.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>O TravaLoL funciona por causa de um bug no client.&lt;/p>
&lt;/blockquote>
&lt;p>Essa explicação é a explicação que você vai achar na grande maioria dos sites. Ela está tecnicamente correta,
mas falta algo a mais.&lt;/p>
&lt;h1 id="travazap">TravaZap&lt;/h1>
&lt;p>O TravaZap é o que me deixou mais curioso, afinal como uma ingênua mensagem pode fazer um aplicativo inteiro travar?&lt;/p>
&lt;p>No começo eu achei que era culpa da aplicação. Mas, para entender o motivo, eu preciso explicar primeiro o que é &lt;strong>Unicode&lt;/strong>&lt;/p>
&lt;h2 id="unicode">Unicode&lt;/h2>
&lt;p>Antes, um pouco de história.&lt;/p>
&lt;p>Quando estamos aprendendo a ler, nós somos introduzidos primeiro ao alfabeto:&lt;/p>
&lt;p>&lt;code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&lt;/code>&lt;/p>
&lt;p>Depois, nós somos introduzidos aos numerais:&lt;/p>
&lt;p>&lt;code>0 1 2 3 4 5 6 7 8 9&lt;/code>&lt;/p>
&lt;p>Nós sabemos que números e letras são coisas diferentes: números são mais usados pra contar e letras são mais usadas
para escrever.&lt;/p>
&lt;p>Infelizmente, o computador só enxerga números. Lembrem-se que o computador é, em seu núcleo, uma máquina para
contar, então ele enxergar apenas números faz até que um pouco de sentido.&lt;/p>
&lt;p>Esses números que o computador enxerga são chamados de &lt;strong>bits&lt;/strong>, e eles são compostos por 0 e 1. &lt;br>
Oito &lt;strong>bits&lt;/strong> são iguais a um &lt;strong>byte&lt;/strong>. Um byte pode ir de 0 a 255.&lt;/p>
&lt;p>Quando o computador começou a se popularizar, foi necessário mostrar texto ao usuário, mensagens mais
claras do que meras luzes em um painel. Então começaram a inventar jeitos de representarem letras usando números.&lt;/p>
&lt;p>O padrão mais usado durante muito tempo foi o &lt;strong>ASCII&lt;/strong>. Ele usa um byte por letra (ou seja, vai de 0 até 255[*]),
diferencia maiúsculas de minúsculas, e tem a maioria dos caracteres com acento. No ASCII, a letra &lt;strong>A&lt;/strong> é codificada
usando o número &lt;strong>65&lt;/strong>.&lt;/p>
&lt;p>Infelizmente, o ASCII, devido a limitações de armazenamento na época, apenas guarda caracteres do alfabeto latino
e alguns acentos. Se você quiser escrever, por exemplo, 私のコックは巨大です, você não vai conseguir usando ASCII.
Obviamente era possível naquela época, já que os japoneses usavam computadores, mas não usando ASCII. Sim, você teria
que trocar de encoding, o que provavelmente iria corromper seu texto, já que apenas os números e caracteres de
letra maiúscula eram iguais entre os encodings da época.&lt;/p>
&lt;p>Você já deve ter visto muitos textos assim, principalmente se você for mais velho:&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/acento.png" alt="Erro de encoding no windows 98">&lt;/p>
&lt;p>Esse erro ocorre porque o sistema operacional, o Windows no caso, estava usando o encoding errado. O padrão é ASCII,
mas o Windows 98 usava uma encoding chamada &lt;a href="https://pt.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1&lt;/a>, também chamada
Latin-1, para encodificar os caracteres em português.&lt;/p>
&lt;p>As pessoas já estavam cansadas de problemas como esse, que limitam a comunicação. E olha que a diferença entre o Latin-1
pro ASCII era pequena: em muitos encodings, o que restava de semelhante ao ASCII eram apenas números e letras maiúsculas.&lt;/p>
&lt;p>O desejo por um padrão universal começou, e o Unicode surgiu a partir daí.&lt;/p>
&lt;p>[*] Tecnicamente o ASCII vai até 127, por motivos que fogem ao assunto desse post.&lt;/p>
&lt;h2 id="utf-8">UTF-8&lt;/h2>
&lt;p>O Unicode representa caracteres em valores chamados de &lt;strong>codepoints&lt;/strong>, e eles são representados exclusivamente em hexadecimal.
Esses caracteres vão desde letras e números em diferentes idiomas até &lt;em>kanjis&lt;/em>, hieroglifos e emojis.&lt;br>
Por exemplo, 💩 é representado pelo codepoint 1F4A9, equivalente a 128169 em decimal.&lt;/p>
&lt;p>Todos os codepoints começam com U seguidos do número, então o codepoint que representa a atual situação do nosso amado país
seria escrito U+1F4A9.&lt;/p>
&lt;p>Porém, esses &lt;strong>codepoints&lt;/strong> não dizem nada sobre como você os representa na máquina. Para isso, existem métodos de mapeamento. Os mais
comuns se chamam UTF, ou &lt;em>Unicode Transformation Format&lt;/em>, algo como &lt;strong>Formato de Transformação Unicode&lt;/strong>, que vai mapear o codepoint em
bytes, para serem usados pelo software.&lt;/p>
&lt;p>O mais popular é o UTF-8. Nele, você usa no mínimo um byte e no máximo oito, se eu não me engano. Os bytes que cada codepoint depende do
número do codepoint. Felizmente, os 127 primeiros caracteres têm o mesmo valor tanto em UTF-8, quanto Unicode e quanto ASCII, então
não há mudanças (por isso que é tão popular). Todos os sistemas operacionais são compatíveis e usam UTF-8.&lt;/p>
&lt;p>Existe o UTF-16, onde você usa entre dois e oito.&lt;/p>
&lt;p>E existe o UTF-32, que você usa entre quatro e oito, se eu não me engano.&lt;/p>
&lt;p>Muito embora, na prática, o limite máximo seja quatro.&lt;/p>
&lt;p>Antigamente, o Windows usava um formato chamado &lt;strong>UCS-2&lt;/strong>, que usava exatamente dois bytes por codepoint.&lt;/p>
&lt;p>E, sim, letra e codepoint são coisas diferentes. Por exemplo, existem duas formas de escrever a letra &lt;code>á&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>U+00E1&lt;/li>
&lt;li>U+0061 U+0301.&lt;/li>
&lt;/ul>
&lt;p>Na primeira forma você usa o codepoint responsavel pela letra &lt;code>á&lt;/code>.&lt;/p>
&lt;p>Na segunda você usa 2 codepoints: um pra letra &lt;code>a&lt;/code> (sem acento) e outro que representa o ato de acentuar o
codepoint anterior.&lt;/p>
&lt;h2 id="navegando-pelo-texto">Navegando pelo texto&lt;/h2>
&lt;p>Você deve estar se perguntando: o que isso tem a ver com o travazap?&lt;/p>
&lt;p>Acalme-se.&lt;/p>
&lt;p>É importante que você veja a explicação, principalmente na parte que eu falei que, no UTF-8,
&lt;em>você usa no mínimo um byte e no máximo seis&lt;/em>.&lt;/p>
&lt;p>Não, o valor de bytes por caractere não é fixo.&lt;/p>
&lt;p>Por exemplo, se convertermos a frase &amp;ldquo;Luladrão roubou meu coração&amp;rdquo; para UTF-8, teremos:
(cada número sendo um byte, em hexadecimal)&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 4c 75 6c 61 64 72 c3 a3 6f 2c 20 72 6f 75 62 6f |Luladr..o, roubo|
L u l a d r --ã-- o , r o u b o
00000010 75 20 6d 65 75 20 63 6f 72 61 c3 a7 c3 a3 6f |u meu cora....o|
u m e u c o r a --ç-- --ã-- o
&lt;/code>&lt;/pre>&lt;p>Perceba que os caracteres com acento ocuparam dois bytes?&lt;/p>
&lt;ul>
&lt;li>&lt;code>ã&lt;/code> é representado pelos bytes C3 e A3 (195 e 163 em decimal).&lt;/li>
&lt;li>&lt;code>ç&lt;/code> é representado pelos bytes C3 e A7 (195 e 167 em decimal).&lt;/li>
&lt;/ul>
&lt;p>Antigamente, em ASCII, um caractere era igual a um byte. Então, para você, por exemplo, andar
dez caracteres para frente num texto, você simplesmente pulava dez bytes. Você nem precisaria
se preocupar no que está escrito, já que o tamanho é fixo.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/squid1.png" alt="Antigamente, as letras eram assim">&lt;/p>
&lt;p>Já no UTF-8, você precisa prestar atenção no byte que você está lendo, para ver se o caractere
tem um ou mais bytes.&lt;/p>
&lt;p>Isso torna operações de manipulação de texto, como contar letras e palavras, além de descobrir
o tamanho de um pedaço de texto em caracteres, relativamente mais difícil.&lt;/p>
&lt;h2 id="escrita">Escrita&lt;/h2>
&lt;p>Algo que se torna mais complicado é desenhar as letras que você vê na tela.&lt;/p>
&lt;p>Antigamente, quando se usava apenas ASCII, o computador ordenava os 256 caracteres do ASCII em uma
lista na memória, e usava o valor da letra para se decidir qual caractere desenhar. Por exemplo, se
você pedisse para ele desenhar o caractere de valor &lt;code>65&lt;/code>, o computador iria ver o 65º caractere da lista,
que seria a letra &amp;ldquo;A&amp;rdquo;, e o desenharia onde você pediu.&lt;/p>
&lt;p>Como eram apenas 256 valores, não tinha problema em ter uma tabela gigantesca em memória.&lt;/p>
&lt;p>Porém, a primeira versão do Unicode já vinha com dezenas de milhares de &amp;ldquo;caracteres&amp;rdquo; (codepoints, na verdade).
A primeira versão lançou ainda na década de 90, onde os computadores possuíam, em média, uns 128 MB de memória.
Uma simples lista caberia, mas não sobraria muito para outros aplicativos.&lt;/p>
&lt;p>Então os cientistas da computação inventaram jeitos melhores de guardar esses caracteres na memória, e diferentes
formatos de fontes de computador nasceram. Jeitos melhores obviamente aumentaram a velocidade, mas aumentavam
também o tamanho desses arquivos, além do consumo de memória da máquina.&lt;/p>
&lt;p>Porém, uma coisa que mudou é que, antigamente, todos os caracteres tinham um tamanho fixo, de alguns pixels.&lt;br>
Por exemplo, se uma letra tem 7 pixels de largura, e você precisa escrever a palavra &lt;code>PAÇOCA&lt;/code>, você sabe que
precisa reservar &lt;code>7&lt;/code> pixels * &lt;code>6&lt;/code> caracteres, ou seja, 42 pixels.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/pafoca.png" alt="&amp;amp;ldquo;Paçoca&amp;amp;rdquo; escrita em diferentes tipos de letra, para ilustrar os diferentes tamanhos">
&lt;!-- raw HTML omitted -->&amp;ldquo;Paçoca&amp;rdquo; escrita em diferentes tipos de letra, para ilustrar os diferentes tamanhos&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>Agora, um caractere pode ter diferentes tamanhos, então o programa nunca sabe qual vai ser o tamanho da letra que
ele vai desenhar até ele desenhar. Sim, a altura ainda é conhecida, mas a largura não.&lt;/p>
&lt;h2 id="problemas">Problemas&lt;/h2>
&lt;p>Então, nós temos dois problemas:&lt;/p>
&lt;ul>
&lt;li>Um &lt;strong>caractere&lt;/strong> pode ser composto por vários &lt;strong>codepoints&lt;/strong>.&lt;/li>
&lt;li>Um &lt;strong>codepoint&lt;/strong> pode ser composto por vários &lt;strong>bytes&lt;/strong>.&lt;/li>
&lt;li>Um &lt;strong>caractere&lt;/strong> pode ter diferentes larguras.&lt;/li>
&lt;li>Além disso, um &lt;strong>caractere&lt;/strong> pode ser desenhado de trás pra frente, ou de cima para baixo.&lt;/li>
&lt;/ul>
&lt;p>Identificar caracteres é difícil, mas desenhá-los na tela é ainda mais.&lt;/p>
&lt;p>O motivo pelo qual isso não parece lento é que os programas geralmente, na hora de editar texto, ou
deixam quatro bytes por codepoint, fazendo com que seja muito mais fácil de navegar, ou usam
algoritmos que permitem navegação rápida, a custo de mais memória consumida.&lt;/p>
&lt;p>Além disso, eles só desenham os caracteres que vão aparecer na tela, o que limita um pouco as coisas.&lt;/p>
&lt;h2 id="voltando-à-questão">Voltando à questão.&lt;/h2>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/travazap.jpg" alt="">
&lt;!-- raw HTML omitted -->Fonte: radaroeste.com.br&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>Até agora, sabemos que:&lt;/p>
&lt;ul>
&lt;li>os caracteres podem ocupar mais de um byte.&lt;/li>
&lt;li>cada caractere pode ter diferentes tamanhos.&lt;/li>
&lt;li>a parte mais demorada envolve desenhar o caractere.&lt;/li>
&lt;/ul>
&lt;p>Dito isso, já posso explicar como funciona o travazap.&lt;/p>
&lt;p>Não, não é nada a ver com os servidores do whatsapp. O Whatsapp usa uma linguagem chamada &lt;strong>Erlang&lt;/strong>
para criar o programa que fica no servidor, enviando as mensagens para os aplicativos lhe mostrarem. &lt;br>
Essa linguagem tem um bom suporte a Unicode.&lt;/p>
&lt;p>O aplicativo em si é feito em Java, se eu não me engano. Java tem um bom suporte a unicode.&lt;/p>
&lt;p>E, para falar a verdade, o tratamento de Unicode já é conhecido faz tempo. Qualquer linguagem de
programação tem funções que lidam com isso.&lt;/p>
&lt;p>O problema está na hora de desenhar.&lt;/p>
&lt;p>&lt;img src="https://arthurmco.github.io/blog/blog/images/trava/pombo.png" alt="">&lt;/p>
&lt;p>Isso é um travazap que eu peguei da internet, inalterado. &lt;br>
Ele tem 110 kB.&lt;br>
Pode não parecer muito, mas isso são, aproximadamente, 100 mil caracteres.&lt;/p>
&lt;p>Você já pode perceber que tem algo errado, já que os travazaps não parecem ser tão grandes.
No máximo eles têm uma tela ou duas. Isso não dá cem mil caracteres nunca, nem na menor
fonte possível que você pode configurar no celular.&lt;/p>
&lt;p>O problema, na verdade, está em &lt;em>desenhar&lt;/em>.&lt;/p>
&lt;p>A maior parte do travazap é composta por esses codepoints aqui:&lt;/p>
&lt;ul>
&lt;li>&lt;code>U+2009&lt;/code>&lt;/li>
&lt;li>&lt;code>U+200A&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Se você souber inglês, vai ver que &lt;a href="https://unicode-explorer.com/c/2009">o nome do primeiro codepoint&lt;/a>
é algo como &amp;ldquo;ESPAÇO PEQUENO&amp;rdquo;, e &lt;a href="https://unicode-explorer.com/c/200A">o nome do segundo&lt;/a>
é algo como &amp;ldquo;ESPAÇO DO TAMANHO DE UM FIO DE CABELO&amp;rdquo;.&lt;/p>
&lt;p>O &lt;code>2009&lt;/code> é o segundo menor espaço disponível, medindo algo como 3 pixels. O &lt;code>200A&lt;/code> é ainda menor do que
isso. Lembrando que as telas de celular de hoje em dia possuem algo como 720 pixels de largura[2],
então cabem uns 300 caracteres desses por linha.&lt;/p>
&lt;p>Esses dois caracteres não são muito difíceis de serem desenhados, mas, ainda assim, o WhatsApp precisa
desenhá-los um a um. E, como os caracteres são bem pequenos, você precisa desenhar muitos deles
para chegar até o final da tela.&lt;/p>
&lt;p>Ao contrário do seu navegador, Chrome ou Firefox, que já é otimizado para lidar com muito texto (
lembrando que, tecnicamente, são &lt;strong>100 mil caracteres de uma vez&lt;/strong> ), o WhatsApp não é, e ele
acaba travando.&lt;/p>
&lt;p>Muitos travazaps contém &lt;em>codepoints&lt;/em> que mudam a direção do texto, o que também afeta a velocidade
de desenho, já que você precisa calcular a medida da letra de trás para frente, e ir andando
pelo texto até achar o &lt;em>codepoint&lt;/em> que volta a direção do texto ao normal.&lt;/p>
&lt;p>&lt;strong>Fato curioso:&lt;/strong> o travazap não funciona com SMS da mesma forma que com o WhatsApp.&lt;br>
Sim, o SMS suporta Unicode, mas ele tem um limite &lt;em>em bytes&lt;/em>, e esse limite é relativamente
pequeno. Então você não vai ver tantos caracteres. &lt;em>MASSSS&lt;/em>, você vai receber muitas mensagens
de uma vez, umas mil, uma atrás da outra.&lt;br>
É &lt;em>isso&lt;/em> é o qe pode travar o seu celular&lt;/p>
&lt;hr>
&lt;p>[2] 720 pixels &lt;em>virtuais&lt;/em>. Na verdade, a tela tem, no mínimo, o dobro dessa resolução, mas ela é
mais usada pelo sistema pra suavizar as bordas das letras e melhorar a definição das imagens.\
Para o aplicativo, é uma tela de 720 pixels.&lt;/p>
&lt;hr>
&lt;p>Pronto, TravaZap explicado!&lt;/p>
&lt;p>Na parte 2, que eu ainda vou escrever, eu vou falar mais ou menos como funciona o TravaLoL novo.
Como eu ainda estou pesquisando, vai demorar um pouco mais.&lt;/p></content></item><item><title>Coisas interessantes sobre patchfiles</title><link>https://arthurmco.github.io/blog/posts/about-patch-files/</link><pubDate>Sun, 13 Mar 2022 14:28:37 -0300</pubDate><guid>https://arthurmco.github.io/blog/posts/about-patch-files/</guid><description>Hoje eu precisei editar um arquivo patch na mão, algo relacionado com um projeto pessoal meu.
Para quem não sabe, arquivos patch são aqueles com extensão .patch. Eles têm um monte de linhas que começam com + e -.
A sintaxe desse arquivo é a mesma sintaxe que o comando git diff mostra em um repositório válido,
Um arquivo diff é mais ou menos assim:
diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt index edeeeec.</description><content>&lt;p>Hoje eu precisei editar um arquivo &lt;code>patch&lt;/code> na mão, algo relacionado
com um projeto pessoal meu.&lt;/p>
&lt;p>Para quem não sabe, arquivos &lt;code>patch&lt;/code> são aqueles com extensão .patch.
Eles têm um monte de linhas que começam com &lt;code>+&lt;/code> e &lt;code>-&lt;/code>.&lt;br>
A sintaxe desse arquivo é a mesma sintaxe que o comando &lt;code>git diff&lt;/code>
mostra em um repositório válido,&lt;/p>
&lt;p>Um arquivo diff é mais ou menos assim:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-diff" data-lang="diff">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index edeeeec..fcbe64c 100644
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">--- a/src/common/CMakeLists.txt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/src/common/CMakeLists.txt
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -48,13 +48,11 @@ add_dependencies(familyline-common input-flatbuffer input-ser-flatbuffer network
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> target_compile_features(familyline-common PRIVATE cxx_std_20)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(fmt 6...7.2 CONFIG REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-find_package(ZLIB REQUIRED)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span> find_package(tl-expected 1 CONFIG REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(nlohmann_json REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(FlatBuffers REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(SDL2 CONFIG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(range-v3 CONFIG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-find_package(glm REQUIRED)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> if (FLINE_USE_VCPKG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include(${CMAKE_TOOLCHAIN_FILE})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">@@ -79,8 +77,9 @@ else()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> target_link_libraries(familyline-common PUBLIC ${CURLPP_LDFLAGS})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target_include_directories(familyline-common PUBLIC ${CURLPP_INCLUDE_DIRS})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endif()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">+ pkg_search_module(ZLIB REQUIRED zlib)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">- target_link_libraries(familyline-common PUBLIC fmt::fmt glm::glm ${ZLIB_LIBRARIES})
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ target_link_libraries(familyline-common PUBLIC fmt::fmt glm ${ZLIB_LIBRARIES})
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span> target_link_libraries(familyline-common PUBLIC tl::expected range-v3::range-v3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target_link_libraries(familyline-common PUBLIC nlohmann_json::nlohmann_json)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target_include_directories(familyline-common PUBLIC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diff --git a/src/common/generated.cmake b/src/common/generated.cmake
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index d30ff1c..b105a41 100644
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">--- a/src/common/generated.cmake
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/src/common/generated.cmake
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -5,6 +5,8 @@
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> # called INPUT_FLATBUFFER_INCLUDE, where the generated header file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> # is.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">+# TODO: solve the issue of us having to run cmake twice to get the flatbuffers path
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span> include_guard(GLOBAL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include(&amp;#34;${CMAKE_SOURCE_DIR}/cmake/BuildFlatBuffers.cmake&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diff --git a/tools/bump_version.py b/tools/bump_version.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index 5b79583..46f736c 100644
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">--- a/tools/bump_version.py
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/tools/bump_version.py
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -127,7 +127,7 @@ update_cmakelists(current_ver, next_ver)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ####################
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.system(&amp;#34;git add CMakeLists.txt&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-os.system(&amp;#34;git commit -m \&amp;#34;Bump version (v{} -&amp;gt; v{})\&amp;#34;&amp;#34;.format(current_ver, next_ver))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+os.system(&amp;#34;git commit --no-verify -m \&amp;#34;Bump version (v{} -&amp;gt; v{})\&amp;#34;&amp;#34;.format(current_ver, next_ver))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ####################
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Existem vários formatos de arquivos de patch. O mais comum é esse aí de cima,
chamado de &lt;code>unified format&lt;/code>&lt;/p>
&lt;p>Um arquivo de patch pode conter vários arquivos. Eles são delimitados
por duas coisas:&lt;/p>
&lt;ul>
&lt;li>o comando usado pra gerar o diff:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>diff --git a/tools/bump_version.py b/tools/bump_version.py
index 5b79583..46f736c 100644
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>o &lt;code>header&lt;/code> do arquivo:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>--- a/tools/bump_version.py
+++ b/tools/bump_version.py
&lt;/code>&lt;/pre>&lt;p>Opcionalmente, esse header pode conter uma data. É útil para ver se o
seu arquivo é mais novo ou mais velho do que o patch&lt;/p>
&lt;pre tabindex="0">&lt;code>--- a/tools/bump_version.py 2022-03-07 01:34:08.815661222 -0300
+++ b/tools/bump_version.py 2022-03-09 18:29:20.993654217 -0300
&lt;/code>&lt;/pre>&lt;p>O &lt;code>---&lt;/code> delimita o arquivo &amp;ldquo;antigo&amp;rdquo;. O &lt;code>+++&lt;/code> delimita o arquivo
&amp;ldquo;novo&amp;rdquo;, que vai surgir depois do path.&lt;/p>
&lt;p>O que conta pro formato é o caminho depois do &lt;code>a/&lt;/code> ou do &lt;code>b&lt;/code>, esses
dois nomes são só de referência&lt;/p>
&lt;p>Depois disso, para cada arquivo, nós temos vários &amp;ldquo;chunks&amp;rdquo;, pedaços de alteração.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-diff" data-lang="diff">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">@@ -127,7 +127,7 @@ update_cmakelists(current_ver, next_ver)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ####################
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.system(&amp;#34;git add CMakeLists.txt&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-os.system(&amp;#34;git commit -m \&amp;#34;Bump version (v{} -&amp;gt; v{})\&amp;#34;&amp;#34;.format(current_ver, next_ver))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+os.system(&amp;#34;git commit --no-verify -m \&amp;#34;Bump version (v{} -&amp;gt; v{})\&amp;#34;&amp;#34;.format(current_ver, next_ver))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ####################
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>O formato é mais ou menos assim:&lt;/p>
&lt;p>&lt;code>@@ -linhaA, quantidadeA +linhaB, quantidadeB @@&lt;/code>&lt;/p>
&lt;p>A &lt;code>linhaA&lt;/code> é o número da linha onde o chunk começa, onde a alteração
vai acontecer no arquivo antigo. A &lt;code>quantidadeA&lt;/code> é a quantidade do
número de linhas nesse &amp;ldquo;chunk&amp;rdquo; no arquivo original&lt;/p>
&lt;p>A &lt;code>linhaB&lt;/code> é o número da linha onde o chunk começa, onde a alteração
vai acontecer no arquivo novo. A &lt;code>quantidadeB&lt;/code> é a quantidade do
número de linhas nesse &amp;ldquo;chunk&amp;rdquo; depois que todas as alterações forem
aplicadas.&lt;/p>
&lt;p>Por exemplo, nesse chunk aí de cima, ele começa na linha 127 do
arquivo, temos 7 linhas nele antes das alterações, e 7 linhas nele
depois&lt;/p>
&lt;p>Nesse aqui:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-diff" data-lang="diff">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">@@ -48,13 +48,11 @@ add_dependencies(familyline-common input-flatbuffer input-ser-flatbuffer network
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> target_compile_features(familyline-common PRIVATE cxx_std_20)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(fmt 6...7.2 CONFIG REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-find_package(ZLIB REQUIRED)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span> find_package(tl-expected 1 CONFIG REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(nlohmann_json REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(FlatBuffers REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(SDL2 CONFIG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> find_package(range-v3 CONFIG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-find_package(glm REQUIRED)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> if (FLINE_USE_VCPKG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include(${CMAKE_TOOLCHAIN_FILE})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ele começa na linha 48 do arquivo original, temos 13 linhas nele antes
das alterações e teremos 11 linhas depois.&lt;/p>
&lt;p>Depois disso, vêm algumas linhas do arquivo original, para dar
contexto.&lt;/p>
&lt;p>As linhas sem nada antes são linhas que não sofrerão alterações.&lt;/p>
&lt;p>As linhas com &lt;code>-&lt;/code> serão removidas.&lt;/p>
&lt;p>As linhas com &lt;code>+&lt;/code> serão adicionadas.&lt;/p>
&lt;hr>
&lt;p>E é isso.&lt;/p>
&lt;p>É um formato relativamente simples, mas bem útil para dizer
alterações.&lt;/p>
&lt;p>Se você quiser mais detalhes sobre o formato, pode vir &lt;a href="https://www.artima.com/weblogs/viewpost.jsp?thread=164293">nesse post do
Guido van
Rossum&lt;/a>,
onde ele escreveu uma mini-especificação do formato.&lt;/p></content></item></channel></rss>